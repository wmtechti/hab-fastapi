# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = User.prisma().query_first(
            'SELECT * FROM User WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = User.prisma().create(
            data={
                # data to create a User record
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                },
                {
                    # data to create a User record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().delete(
            where={
                'id': 'ggciceaie',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().find_unique(
            where={
                'id': 'bbehjachib',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().find_unique_or_raise(
            where={
                'id': 'cadfabfehe',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the emailVerified field
        user = User.prisma().find_first(
            skip=1,
            order={
                'emailVerified': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the image field
        user = User.prisma().find_first_or_raise(
            skip=1,
            order={
                'image': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = User.prisma().update(
            where={
                'id': 'dgiiaaijj',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().upsert(
            where={
                'id': 'bfaiacjjfc',
            },
            data={
                'create': {
                    'id': 'bfaiacjjfc',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = User.prisma().update_many(
            data={
                'stripeCustomerId': 'eigcfgbif'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = User.prisma().count(
            select={
                '_all': True,
                'stripeSubscriptionId': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = User.prisma().count(
            select={
                '_all': True,
                'stripeSubscriptionStatus': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = User.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by stripePriceId values
        # and count how many records are in each group
        results = User.prisma().group_by(
            ['stripePriceId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Profile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Profile.prisma().query_raw(
            'SELECT * FROM Profile WHERE id = $1',
            'bagcfbhiig',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Profile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Profile.prisma().query_first(
            'SELECT * FROM Profile WHERE roleId = $1',
            'cghideieh',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.ProfileCreateInput,
        include: Optional[types.ProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new Profile record.

        Parameters
        ----------
        data
            Profile record data
        include
            Specifies which relations should be loaded on the returned Profile model

        Returns
        -------
        prisma.models.Profile
            The created Profile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Profile record from just the required fields
        profile = Profile.prisma().create(
            data={
                # data to create a Profile record
                'roleId': 'biabhbdai',
                'userId': 'idghgaicb',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.ProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Profile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Profile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Profile.prisma().create_many(
            data=[
                {
                    # data to create a Profile record
                    'roleId': 'fjfddhigg',
                    'userId': 'hjaecfifb',
                },
                {
                    # data to create a Profile record
                    'roleId': 'cbbbjbfcii',
                    'userId': 'bbejhfidcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Profile record.

        Parameters
        ----------
        where
            Profile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Profile model

        Returns
        -------
        prisma.models.Profile
            The deleted Profile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        profile = Profile.prisma().delete(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Profile record.

        Parameters
        ----------
        where
            Profile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Profile model

        Returns
        -------
        prisma.models.Profile
            The found Profile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        profile = Profile.prisma().find_unique(
            where={
                'id': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Profile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Profile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Profile model

        Returns
        -------
        prisma.models.Profile
            The found Profile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        profile = Profile.prisma().find_unique_or_raise(
            where={
                'id': 'bgehebiafc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
        include: Optional[types.ProfileInclude] = None,
        order: Optional[Union[types.ProfileOrderByInput, List[types.ProfileOrderByInput]]] = None,
        distinct: Optional[List[types.ProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Profile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Profile records returned
        skip
            Ignore the first N results
        where
            Profile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Profile model
        order
            Order the returned Profile records by any field
        distinct
            Filter Profile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Profile]
            The list of all Profile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Profile records
        profiles = Profile.prisma().find_many(take=10)

        # find the first 5 Profile records ordered by the userId field
        profiles = Profile.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
        include: Optional[types.ProfileInclude] = None,
        order: Optional[Union[types.ProfileOrderByInput, List[types.ProfileOrderByInput]]] = None,
        distinct: Optional[List[types.ProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Profile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Profile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Profile model
        order
            Order the returned Profile records by any field
        distinct
            Filter Profile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Profile
            The first Profile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Profile record ordered by the id field
        profile = Profile.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
        include: Optional[types.ProfileInclude] = None,
        order: Optional[Union[types.ProfileOrderByInput, List[types.ProfileOrderByInput]]] = None,
        distinct: Optional[List[types.ProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Profile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Profile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Profile model
        order
            Order the returned Profile records by any field
        distinct
            Filter Profile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Profile
            The first Profile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Profile record ordered by the roleId field
        profile = Profile.prisma().find_first_or_raise(
            skip=1,
            order={
                'roleId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.ProfileUpdateInput,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Profile record.

        Parameters
        ----------
        data
            Profile record data specifying what to update
        where
            Profile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Profile model

        Returns
        -------
        prisma.models.Profile
            The updated Profile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        profile = Profile.prisma().update(
            where={
                'id': 'bghffegacj',
            },
            data={
                # data to update the Profile record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.ProfileWhereUniqueInput,
        data: types.ProfileUpsertInput,
        include: Optional[types.ProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Profile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Profile model

        Returns
        -------
        prisma.models.Profile
            The created or updated Profile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        profile = Profile.prisma().upsert(
            where={
                'id': 'bhghchehcc',
            },
            data={
                'create': {
                    'id': 'bhghchehcc',
                    'roleId': 'cbbbjbfcii',
                    'userId': 'bbejhfidcb',
                },
                'update': {
                    'roleId': 'cbbbjbfcii',
                    'userId': 'bbejhfidcb',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.ProfileUpdateManyMutationInput,
        where: types.ProfileWhereInput,
    ) -> int:
        """Update multiple Profile records

        Parameters
        ----------
        data
            Profile data to update the selected Profile records to
        where
            Filter to select the Profile records to update

        Returns
        -------
        int
            The total number of Profile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Profile records
        total = Profile.prisma().update_many(
            data={
                'userId': 'dcgchcbbf'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Profile records present in the database

        Parameters
        ----------
        select
            Select the Profile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Profile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Profile.prisma().count()

        # results: prisma.types.ProfileCountAggregateOutput
        results = Profile.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.ProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
    ) -> types.ProfileCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.ProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
    ) -> Union[int, types.ProfileCountAggregateOutput]:
        """Count the number of Profile records present in the database

        Parameters
        ----------
        select
            Select the Profile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Profile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Profile.prisma().count()

        # results: prisma.types.ProfileCountAggregateOutput
        results = Profile.prisma().count(
            select={
                '_all': True,
                'roleId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProfileCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.ProfileWhereInput] = None
    ) -> int:
        """Delete multiple Profile records.

        Parameters
        ----------
        where
            Optional Profile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Profile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Profile records
        total = Profile.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.ProfileScalarFieldKeys'],
        *,
        where: Optional['types.ProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProfileAvgAggregateInput'] = None,
        sum: Optional['types.ProfileSumAggregateInput'] = None,
        min: Optional['types.ProfileMinAggregateInput'] = None,
        max: Optional['types.ProfileMaxAggregateInput'] = None,
        having: Optional['types.ProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProfileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProfileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProfileGroupByOutput']:
        """Group Profile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Profile fields to group records by
        where
            Profile filter to select records
        take
            Limit the maximum number of Profile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProfileGroupByOutput]
            A list of dictionaries representing the Profile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Profile records by userId values
        # and count how many records are in each group
        results = Profile.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RoleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Role]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Role.prisma().query_raw(
            'SELECT * FROM Role WHERE id = $1',
            'bdedcabahc',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Role
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Role.prisma().query_first(
            'SELECT * FROM Role WHERE name = $1',
            'ghfhiafcb',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.RoleCreateInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Role record.

        Parameters
        ----------
        data
            Role record data
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created Role record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Role record from just the required fields
        role = Role.prisma().create(
            data={
                # data to create a Role record
                'name': 'heejgedji',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.RoleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Role records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Role record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Role.prisma().create_many(
            data=[
                {
                    # data to create a Role record
                    'name': 'bjgjgibgbf',
                },
                {
                    # data to create a Role record
                    'name': 'bbbgbhfjge',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Role record.

        Parameters
        ----------
        where
            Role filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The deleted Role record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().delete(
            where={
                'id': 'igbehcbab',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Role record.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().find_unique(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Role record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().find_unique_or_raise(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Role records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N results
        where
            Role filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Role]
            The list of all Role records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Role records
        roles = Role.prisma().find_many(take=10)

        # find the first 5 Role records ordered by the id field
        roles = Role.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Role record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the name field
        role = Role.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Role record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the id field
        role = Role.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.RoleUpdateInput,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Role record.

        Parameters
        ----------
        data
            Role record data specifying what to update
        where
            Role filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The updated Role record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        role = Role.prisma().update(
            where={
                'id': 'caaaedabfc',
            },
            data={
                # data to update the Role record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.RoleWhereUniqueInput,
        data: types.RoleUpsertInput,
        include: Optional[types.RoleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Role filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created or updated Role record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().upsert(
            where={
                'id': 'bigibebcib',
            },
            data={
                'create': {
                    'id': 'bigibebcib',
                    'name': 'bbbgbhfjge',
                },
                'update': {
                    'name': 'bbbgbhfjge',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.RoleUpdateManyMutationInput,
        where: types.RoleWhereInput,
    ) -> int:
        """Update multiple Role records

        Parameters
        ----------
        data
            Role data to update the selected Role records to
        where
            Filter to select the Role records to update

        Returns
        -------
        int
            The total number of Role records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Role records
        total = Role.prisma().update_many(
            data={
                'name': 'bigaiehgcc'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = Role.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.RoleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> types.RoleCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.RoleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> Union[int, types.RoleCountAggregateOutput]:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = Role.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RoleCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.RoleWhereInput] = None
    ) -> int:
        """Delete multiple Role records.

        Parameters
        ----------
        where
            Optional Role filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Role records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Role records
        total = Role.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.RoleScalarFieldKeys'],
        *,
        where: Optional['types.RoleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RoleAvgAggregateInput'] = None,
        sum: Optional['types.RoleSumAggregateInput'] = None,
        min: Optional['types.RoleMinAggregateInput'] = None,
        max: Optional['types.RoleMaxAggregateInput'] = None,
        having: Optional['types.RoleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RoleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RoleGroupByOutput']:
        """Group Role records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Role fields to group records by
        where
            Role filter to select records
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RoleGroupByOutput]
            A list of dictionaries representing the Role record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Role records by id values
        # and count how many records are in each group
        results = Role.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GymActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Gym]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Gym.prisma().query_raw(
            'SELECT * FROM Gym WHERE id = $1',
            'beeifcbebf',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Gym
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Gym.prisma().query_first(
            'SELECT * FROM Gym WHERE name = $1',
            'bgcigfahea',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.GymCreateInput,
        include: Optional[types.GymInclude] = None
    ) -> _PrismaModelT:
        """Create a new Gym record.

        Parameters
        ----------
        data
            Gym record data
        include
            Specifies which relations should be loaded on the returned Gym model

        Returns
        -------
        prisma.models.Gym
            The created Gym record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Gym record from just the required fields
        gym = Gym.prisma().create(
            data={
                # data to create a Gym record
                'name': 'bcejgaggif',
                'location': 'idfjadbcc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.GymCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Gym records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Gym record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Gym.prisma().create_many(
            data=[
                {
                    # data to create a Gym record
                    'name': 'hgdhbjhhj',
                    'location': 'ecjjjfbae',
                },
                {
                    # data to create a Gym record
                    'name': 'bhhfibbigf',
                    'location': 'ijdbeffgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.GymWhereUniqueInput,
        include: Optional[types.GymInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Gym record.

        Parameters
        ----------
        where
            Gym filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Gym model

        Returns
        -------
        prisma.models.Gym
            The deleted Gym record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gym = Gym.prisma().delete(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.GymWhereUniqueInput,
        include: Optional[types.GymInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Gym record.

        Parameters
        ----------
        where
            Gym filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Gym model

        Returns
        -------
        prisma.models.Gym
            The found Gym record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gym = Gym.prisma().find_unique(
            where={
                'id': 'cbachdgfce',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.GymWhereUniqueInput,
        include: Optional[types.GymInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Gym record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Gym filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Gym model

        Returns
        -------
        prisma.models.Gym
            The found Gym record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gym = Gym.prisma().find_unique_or_raise(
            where={
                'id': 'chbfcacbd',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GymWhereInput] = None,
        cursor: Optional[types.GymWhereUniqueInput] = None,
        include: Optional[types.GymInclude] = None,
        order: Optional[Union[types.GymOrderByInput, List[types.GymOrderByInput]]] = None,
        distinct: Optional[List[types.GymScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Gym records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Gym records returned
        skip
            Ignore the first N results
        where
            Gym filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Gym model
        order
            Order the returned Gym records by any field
        distinct
            Filter Gym records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Gym]
            The list of all Gym records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Gym records
        gyms = Gym.prisma().find_many(take=10)

        # find the first 5 Gym records ordered by the location field
        gyms = Gym.prisma().find_many(
            take=5,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GymWhereInput] = None,
        cursor: Optional[types.GymWhereUniqueInput] = None,
        include: Optional[types.GymInclude] = None,
        order: Optional[Union[types.GymOrderByInput, List[types.GymOrderByInput]]] = None,
        distinct: Optional[List[types.GymScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Gym record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Gym filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Gym model
        order
            Order the returned Gym records by any field
        distinct
            Filter Gym records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Gym
            The first Gym record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Gym record ordered by the responsibleId field
        gym = Gym.prisma().find_first(
            skip=1,
            order={
                'responsibleId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GymWhereInput] = None,
        cursor: Optional[types.GymWhereUniqueInput] = None,
        include: Optional[types.GymInclude] = None,
        order: Optional[Union[types.GymOrderByInput, List[types.GymOrderByInput]]] = None,
        distinct: Optional[List[types.GymScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Gym record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Gym filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Gym model
        order
            Order the returned Gym records by any field
        distinct
            Filter Gym records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Gym
            The first Gym record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Gym record ordered by the id field
        gym = Gym.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.GymUpdateInput,
        where: types.GymWhereUniqueInput,
        include: Optional[types.GymInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Gym record.

        Parameters
        ----------
        data
            Gym record data specifying what to update
        where
            Gym filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Gym model

        Returns
        -------
        prisma.models.Gym
            The updated Gym record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        gym = Gym.prisma().update(
            where={
                'id': 'efggddide',
            },
            data={
                # data to update the Gym record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.GymWhereUniqueInput,
        data: types.GymUpsertInput,
        include: Optional[types.GymInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Gym filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Gym model

        Returns
        -------
        prisma.models.Gym
            The created or updated Gym record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        gym = Gym.prisma().upsert(
            where={
                'id': 'caficfigfb',
            },
            data={
                'create': {
                    'id': 'caficfigfb',
                    'name': 'bhhfibbigf',
                    'location': 'ijdbeffgg',
                },
                'update': {
                    'name': 'bhhfibbigf',
                    'location': 'ijdbeffgg',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.GymUpdateManyMutationInput,
        where: types.GymWhereInput,
    ) -> int:
        """Update multiple Gym records

        Parameters
        ----------
        data
            Gym data to update the selected Gym records to
        where
            Filter to select the Gym records to update

        Returns
        -------
        int
            The total number of Gym records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Gym records
        total = Gym.prisma().update_many(
            data={
                'name': 'bfidgijfjc'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GymWhereInput] = None,
        cursor: Optional[types.GymWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Gym records present in the database

        Parameters
        ----------
        select
            Select the Gym fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Gym filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GymCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Gym.prisma().count()

        # results: prisma.types.GymCountAggregateOutput
        results = Gym.prisma().count(
            select={
                '_all': True,
                'location': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.GymCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GymWhereInput] = None,
        cursor: Optional[types.GymWhereUniqueInput] = None,
    ) -> types.GymCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.GymCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GymWhereInput] = None,
        cursor: Optional[types.GymWhereUniqueInput] = None,
    ) -> Union[int, types.GymCountAggregateOutput]:
        """Count the number of Gym records present in the database

        Parameters
        ----------
        select
            Select the Gym fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Gym filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GymCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Gym.prisma().count()

        # results: prisma.types.GymCountAggregateOutput
        results = Gym.prisma().count(
            select={
                '_all': True,
                'responsibleId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GymCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.GymWhereInput] = None
    ) -> int:
        """Delete multiple Gym records.

        Parameters
        ----------
        where
            Optional Gym filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Gym records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Gym records
        total = Gym.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.GymScalarFieldKeys'],
        *,
        where: Optional['types.GymWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GymAvgAggregateInput'] = None,
        sum: Optional['types.GymSumAggregateInput'] = None,
        min: Optional['types.GymMinAggregateInput'] = None,
        max: Optional['types.GymMaxAggregateInput'] = None,
        having: Optional['types.GymScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GymCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GymScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GymScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GymGroupByOutput']:
        """Group Gym records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Gym fields to group records by
        where
            Gym filter to select records
        take
            Limit the maximum number of Gym records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GymGroupByOutput]
            A list of dictionaries representing the Gym record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Gym records by id values
        # and count how many records are in each group
        results = Gym.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserTypeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserType]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = UserType.prisma().query_raw(
            'SELECT * FROM UserType WHERE id = $1',
            'ihieecagf',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserType
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = UserType.prisma().query_first(
            'SELECT * FROM UserType WHERE perfil = $1',
            'bghfciaafe',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.UserTypeCreateInput,
        include: Optional[types.UserTypeInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserType record.

        Parameters
        ----------
        data
            UserType record data
        include
            Specifies which relations should be loaded on the returned UserType model

        Returns
        -------
        prisma.models.UserType
            The created UserType record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserType record from just the required fields
        usertype = UserType.prisma().create(
            data={
                # data to create a UserType record
                'perfil': 'bgchfhgceh',
                'userId': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.UserTypeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserType records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserType record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = UserType.prisma().create_many(
            data=[
                {
                    # data to create a UserType record
                    'perfil': 'gaddfhfh',
                    'userId': 'gieegcbeg',
                },
                {
                    # data to create a UserType record
                    'perfil': 'bgcffadich',
                    'userId': 'fcbichhci',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.UserTypeWhereUniqueInput,
        include: Optional[types.UserTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserType record.

        Parameters
        ----------
        where
            UserType filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserType model

        Returns
        -------
        prisma.models.UserType
            The deleted UserType record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usertype = UserType.prisma().delete(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.UserTypeWhereUniqueInput,
        include: Optional[types.UserTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserType record.

        Parameters
        ----------
        where
            UserType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserType model

        Returns
        -------
        prisma.models.UserType
            The found UserType record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usertype = UserType.prisma().find_unique(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.UserTypeWhereUniqueInput,
        include: Optional[types.UserTypeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserType record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserType model

        Returns
        -------
        prisma.models.UserType
            The found UserType record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usertype = UserType.prisma().find_unique_or_raise(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserTypeWhereInput] = None,
        cursor: Optional[types.UserTypeWhereUniqueInput] = None,
        include: Optional[types.UserTypeInclude] = None,
        order: Optional[Union[types.UserTypeOrderByInput, List[types.UserTypeOrderByInput]]] = None,
        distinct: Optional[List[types.UserTypeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserType records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserType records returned
        skip
            Ignore the first N results
        where
            UserType filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserType model
        order
            Order the returned UserType records by any field
        distinct
            Filter UserType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserType]
            The list of all UserType records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserType records
        usertypes = UserType.prisma().find_many(take=10)

        # find the first 5 UserType records ordered by the userId field
        usertypes = UserType.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserTypeWhereInput] = None,
        cursor: Optional[types.UserTypeWhereUniqueInput] = None,
        include: Optional[types.UserTypeInclude] = None,
        order: Optional[Union[types.UserTypeOrderByInput, List[types.UserTypeOrderByInput]]] = None,
        distinct: Optional[List[types.UserTypeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserType record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserType model
        order
            Order the returned UserType records by any field
        distinct
            Filter UserType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserType
            The first UserType record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserType record ordered by the id field
        usertype = UserType.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserTypeWhereInput] = None,
        cursor: Optional[types.UserTypeWhereUniqueInput] = None,
        include: Optional[types.UserTypeInclude] = None,
        order: Optional[Union[types.UserTypeOrderByInput, List[types.UserTypeOrderByInput]]] = None,
        distinct: Optional[List[types.UserTypeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserType record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserType model
        order
            Order the returned UserType records by any field
        distinct
            Filter UserType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserType
            The first UserType record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserType record ordered by the perfil field
        usertype = UserType.prisma().find_first_or_raise(
            skip=1,
            order={
                'perfil': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.UserTypeUpdateInput,
        where: types.UserTypeWhereUniqueInput,
        include: Optional[types.UserTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserType record.

        Parameters
        ----------
        data
            UserType record data specifying what to update
        where
            UserType filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserType model

        Returns
        -------
        prisma.models.UserType
            The updated UserType record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usertype = UserType.prisma().update(
            where={
                'id': 'gifdddbia',
            },
            data={
                # data to update the UserType record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.UserTypeWhereUniqueInput,
        data: types.UserTypeUpsertInput,
        include: Optional[types.UserTypeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserType filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserType model

        Returns
        -------
        prisma.models.UserType
            The created or updated UserType record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usertype = UserType.prisma().upsert(
            where={
                'id': 'bchehecef',
            },
            data={
                'create': {
                    'id': 'bchehecef',
                    'perfil': 'bgcffadich',
                    'userId': 'fcbichhci',
                },
                'update': {
                    'perfil': 'bgcffadich',
                    'userId': 'fcbichhci',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.UserTypeUpdateManyMutationInput,
        where: types.UserTypeWhereInput,
    ) -> int:
        """Update multiple UserType records

        Parameters
        ----------
        data
            UserType data to update the selected UserType records to
        where
            Filter to select the UserType records to update

        Returns
        -------
        int
            The total number of UserType records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserType records
        total = UserType.prisma().update_many(
            data={
                'userId': 'jeijcbhfe'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserTypeWhereInput] = None,
        cursor: Optional[types.UserTypeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserType records present in the database

        Parameters
        ----------
        select
            Select the UserType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = UserType.prisma().count()

        # results: prisma.types.UserTypeCountAggregateOutput
        results = UserType.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.UserTypeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserTypeWhereInput] = None,
        cursor: Optional[types.UserTypeWhereUniqueInput] = None,
    ) -> types.UserTypeCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.UserTypeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserTypeWhereInput] = None,
        cursor: Optional[types.UserTypeWhereUniqueInput] = None,
    ) -> Union[int, types.UserTypeCountAggregateOutput]:
        """Count the number of UserType records present in the database

        Parameters
        ----------
        select
            Select the UserType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = UserType.prisma().count()

        # results: prisma.types.UserTypeCountAggregateOutput
        results = UserType.prisma().count(
            select={
                '_all': True,
                'perfil': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserTypeCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.UserTypeWhereInput] = None
    ) -> int:
        """Delete multiple UserType records.

        Parameters
        ----------
        where
            Optional UserType filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserType records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserType records
        total = UserType.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.UserTypeScalarFieldKeys'],
        *,
        where: Optional['types.UserTypeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserTypeAvgAggregateInput'] = None,
        sum: Optional['types.UserTypeSumAggregateInput'] = None,
        min: Optional['types.UserTypeMinAggregateInput'] = None,
        max: Optional['types.UserTypeMaxAggregateInput'] = None,
        having: Optional['types.UserTypeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserTypeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserTypeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserTypeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserTypeGroupByOutput']:
        """Group UserType records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserType fields to group records by
        where
            UserType filter to select records
        take
            Limit the maximum number of UserType records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserTypeGroupByOutput]
            A list of dictionaries representing the UserType record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserType records by userId values
        # and count how many records are in each group
        results = UserType.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Account]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Account.prisma().query_raw(
            'SELECT * FROM Account WHERE id = $1',
            'bjgejjabff',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Account
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Account.prisma().query_first(
            'SELECT * FROM Account WHERE userId = $1',
            'bcciijbibg',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.AccountCreateInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Create a new Account record.

        Parameters
        ----------
        data
            Account record data
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created Account record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Account record from just the required fields
        account = Account.prisma().create(
            data={
                # data to create a Account record
                'userId': 'cffcachfd',
                'type': 'bccdfhdigc',
                'provider': 'febcgjbfj',
                'providerAccountId': 'bageiegghg',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.AccountCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Account records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Account record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Account.prisma().create_many(
            data=[
                {
                    # data to create a Account record
                    'userId': 'faidicegb',
                    'type': 'bacecgfhbe',
                    'provider': 'ihcahiead',
                    'providerAccountId': 'biheheiajg',
                },
                {
                    # data to create a Account record
                    'userId': 'jbgijghgb',
                    'type': 'hgjcghfbi',
                    'provider': 'icadbcehj',
                    'providerAccountId': 'jchciaee',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Account record.

        Parameters
        ----------
        where
            Account filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The deleted Account record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = Account.prisma().delete(
            where={
                'id': 'deeificjd',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Account record.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = Account.prisma().find_unique(
            where={
                'id': 'bbcbhebbda',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Account record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = Account.prisma().find_unique_or_raise(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Account records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N results
        where
            Account filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Account]
            The list of all Account records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Account records
        accounts = Account.prisma().find_many(take=10)

        # find the first 5 Account records ordered by the type field
        accounts = Account.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Account record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the provider field
        account = Account.prisma().find_first(
            skip=1,
            order={
                'provider': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Account record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the providerAccountId field
        account = Account.prisma().find_first_or_raise(
            skip=1,
            order={
                'providerAccountId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.AccountUpdateInput,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Account record.

        Parameters
        ----------
        data
            Account record data specifying what to update
        where
            Account filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The updated Account record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        account = Account.prisma().update(
            where={
                'id': 'caifcbgii',
            },
            data={
                # data to update the Account record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.AccountWhereUniqueInput,
        data: types.AccountUpsertInput,
        include: Optional[types.AccountInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Account filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created or updated Account record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = Account.prisma().upsert(
            where={
                'id': 'igaibbfgj',
            },
            data={
                'create': {
                    'id': 'igaibbfgj',
                    'userId': 'jbgijghgb',
                    'type': 'hgjcghfbi',
                    'provider': 'icadbcehj',
                    'providerAccountId': 'jchciaee',
                },
                'update': {
                    'userId': 'jbgijghgb',
                    'type': 'hgjcghfbi',
                    'provider': 'icadbcehj',
                    'providerAccountId': 'jchciaee',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.AccountUpdateManyMutationInput,
        where: types.AccountWhereInput,
    ) -> int:
        """Update multiple Account records

        Parameters
        ----------
        data
            Account data to update the selected Account records to
        where
            Filter to select the Account records to update

        Returns
        -------
        int
            The total number of Account records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Account records
        total = Account.prisma().update_many(
            data={
                'refresh_token': 'bggajdcbbi'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = Account.prisma().count(
            select={
                '_all': True,
                'access_token': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.AccountCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> types.AccountCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.AccountCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> Union[int, types.AccountCountAggregateOutput]:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = Account.prisma().count(
            select={
                '_all': True,
                'expires_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.AccountWhereInput] = None
    ) -> int:
        """Delete multiple Account records.

        Parameters
        ----------
        where
            Optional Account filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Account records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Account records
        total = Account.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.AccountScalarFieldKeys'],
        *,
        where: Optional['types.AccountWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountAvgAggregateInput'] = None,
        sum: Optional['types.AccountSumAggregateInput'] = None,
        min: Optional['types.AccountMinAggregateInput'] = None,
        max: Optional['types.AccountMaxAggregateInput'] = None,
        having: Optional['types.AccountScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountGroupByOutput']:
        """Group Account records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Account fields to group records by
        where
            Account filter to select records
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountGroupByOutput]
            A list of dictionaries representing the Account record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Account records by token_type values
        # and count how many records are in each group
        results = Account.prisma().group_by(
            ['token_type'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'fcfhgbjed',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Session.prisma().query_first(
            'SELECT * FROM Session WHERE sessionToken = $1',
            'hdgcajhjg',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = Session.prisma().create(
            data={
                # data to create a Session record
                'sessionToken': 'ejdjahicb',
                'userId': 'gdjgigfgc',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'sessionToken': 'gfeaahdeh',
                    'userId': 'bjafcgbffc',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'sessionToken': 'hihegjif',
                    'userId': 'bdjidcidac',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = Session.prisma().delete(
            where={
                'id': 'ifgaaagff',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = Session.prisma().find_unique(
            where={
                'id': 'befcddgjce',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = Session.prisma().find_unique_or_raise(
            where={
                'id': 'bfhdbjjgfd',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the userId field
        sessions = Session.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expires field
        session = Session.prisma().find_first(
            skip=1,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the id field
        session = Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = Session.prisma().update(
            where={
                'id': 'cabdjadaji',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = Session.prisma().upsert(
            where={
                'id': 'faajgfadf',
            },
            data={
                'create': {
                    'id': 'faajgfadf',
                    'sessionToken': 'hihegjif',
                    'userId': 'bdjidcidac',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'sessionToken': 'hihegjif',
                    'userId': 'bdjidcidac',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = Session.prisma().update_many(
            data={
                'sessionToken': 'biaagcedjc'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = Session.prisma().count(
            select={
                '_all': True,
                'expires': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = Session.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by id values
        # and count how many records are in each group
        results = Session.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VerificationTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.VerificationToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = VerificationToken.prisma().query_raw(
            'SELECT * FROM VerificationToken WHERE identifier = $1',
            'cahhaghecf',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.VerificationToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = VerificationToken.prisma().query_first(
            'SELECT * FROM VerificationToken WHERE token = $1',
            'bghcbbcidi',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.VerificationTokenCreateInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created VerificationToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a VerificationToken record from just the required fields
        verificationtoken = VerificationToken.prisma().create(
            data={
                # data to create a VerificationToken record
                'identifier': 'jcgghhgdj',
                'token': 'beehgcebbg',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.VerificationTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple VerificationToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of VerificationToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = VerificationToken.prisma().create_many(
            data=[
                {
                    # data to create a VerificationToken record
                    'identifier': 'bhdiaidiaf',
                    'token': 'deajegcfi',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a VerificationToken record
                    'identifier': 'gabahhhjf',
                    'token': 'cjagadcjg',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The deleted VerificationToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = VerificationToken.prisma().delete(
            where={
                'token': 'bifficggej',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = VerificationToken.prisma().find_unique(
            where={
                'token': 'bgbbaajbic',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique VerificationToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = VerificationToken.prisma().find_unique_or_raise(
            where={
                'token': 'eegghdhjb',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple VerificationToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N results
        where
            VerificationToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.VerificationToken]
            The list of all VerificationToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 VerificationToken records
        verificationtokens = VerificationToken.prisma().find_many(take=10)

        # find the first 5 VerificationToken records ordered by the expires field
        verificationtokens = VerificationToken.prisma().find_many(
            take=5,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single VerificationToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the identifier field
        verificationtoken = VerificationToken.prisma().find_first(
            skip=1,
            order={
                'identifier': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single VerificationToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the token field
        verificationtoken = VerificationToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.VerificationTokenUpdateInput,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data specifying what to update
        where
            VerificationToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The updated VerificationToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        verificationtoken = VerificationToken.prisma().update(
            where={
                'token': 'daafgidjg',
            },
            data={
                # data to update the VerificationToken record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        data: types.VerificationTokenUpsertInput,
        include: Optional[types.VerificationTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            VerificationToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created or updated VerificationToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = VerificationToken.prisma().upsert(
            where={
                'token': 'gdcgcgagj',
            },
            data={
                'create': {
                    'token': 'gdcgcgagj',
                    'identifier': 'gabahhhjf',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'identifier': 'gabahhhjf',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.VerificationTokenUpdateManyMutationInput,
        where: types.VerificationTokenWhereInput,
    ) -> int:
        """Update multiple VerificationToken records

        Parameters
        ----------
        data
            VerificationToken data to update the selected VerificationToken records to
        where
            Filter to select the VerificationToken records to update

        Returns
        -------
        int
            The total number of VerificationToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all VerificationToken records
        total = VerificationToken.prisma().update_many(
            data={
                'expires': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = VerificationToken.prisma().count(
            select={
                '_all': True,
                'identifier': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.VerificationTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> types.VerificationTokenCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.VerificationTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> Union[int, types.VerificationTokenCountAggregateOutput]:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = VerificationToken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VerificationTokenCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.VerificationTokenWhereInput] = None
    ) -> int:
        """Delete multiple VerificationToken records.

        Parameters
        ----------
        where
            Optional VerificationToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of VerificationToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all VerificationToken records
        total = VerificationToken.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.VerificationTokenScalarFieldKeys'],
        *,
        where: Optional['types.VerificationTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VerificationTokenAvgAggregateInput'] = None,
        sum: Optional['types.VerificationTokenSumAggregateInput'] = None,
        min: Optional['types.VerificationTokenMinAggregateInput'] = None,
        max: Optional['types.VerificationTokenMaxAggregateInput'] = None,
        having: Optional['types.VerificationTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VerificationTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VerificationTokenGroupByOutput']:
        """Group VerificationToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar VerificationToken fields to group records by
        where
            VerificationToken filter to select records
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VerificationTokenGroupByOutput]
            A list of dictionaries representing the VerificationToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group VerificationToken records by expires values
        # and count how many records are in each group
        results = VerificationToken.prisma().group_by(
            ['expires'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TodoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Todo]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Todo.prisma().query_raw(
            'SELECT * FROM Todo WHERE id = $1',
            'bhceabbgja',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Todo
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Todo.prisma().query_first(
            'SELECT * FROM Todo WHERE title = $1',
            'ehabfhegh',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TodoCreateInput,
        include: Optional[types.TodoInclude] = None
    ) -> _PrismaModelT:
        """Create a new Todo record.

        Parameters
        ----------
        data
            Todo record data
        include
            Specifies which relations should be loaded on the returned Todo model

        Returns
        -------
        prisma.models.Todo
            The created Todo record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Todo record from just the required fields
        todo = Todo.prisma().create(
            data={
                # data to create a Todo record
                'title': 'bcajcajjbc',
                'userId': 'bfdgheeegf',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.TodoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Todo records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Todo record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Todo.prisma().create_many(
            data=[
                {
                    # data to create a Todo record
                    'title': 'ececbijji',
                    'userId': 'cbcfgdcdhf',
                },
                {
                    # data to create a Todo record
                    'title': 'fdgjfbhia',
                    'userId': 'jcehcdchh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TodoWhereUniqueInput,
        include: Optional[types.TodoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Todo record.

        Parameters
        ----------
        where
            Todo filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Todo model

        Returns
        -------
        prisma.models.Todo
            The deleted Todo record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        todo = Todo.prisma().delete(
            where={
                'id': 'bgcbjdhjcc',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.TodoWhereUniqueInput,
        include: Optional[types.TodoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Todo record.

        Parameters
        ----------
        where
            Todo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Todo model

        Returns
        -------
        prisma.models.Todo
            The found Todo record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        todo = Todo.prisma().find_unique(
            where={
                'id': 'bieiidcabj',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.TodoWhereUniqueInput,
        include: Optional[types.TodoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Todo record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Todo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Todo model

        Returns
        -------
        prisma.models.Todo
            The found Todo record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        todo = Todo.prisma().find_unique_or_raise(
            where={
                'id': 'bjcbfcieaa',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TodoWhereInput] = None,
        cursor: Optional[types.TodoWhereUniqueInput] = None,
        include: Optional[types.TodoInclude] = None,
        order: Optional[Union[types.TodoOrderByInput, List[types.TodoOrderByInput]]] = None,
        distinct: Optional[List[types.TodoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Todo records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Todo records returned
        skip
            Ignore the first N results
        where
            Todo filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Todo model
        order
            Order the returned Todo records by any field
        distinct
            Filter Todo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Todo]
            The list of all Todo records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Todo records
        todos = Todo.prisma().find_many(take=10)

        # find the first 5 Todo records ordered by the userId field
        todos = Todo.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TodoWhereInput] = None,
        cursor: Optional[types.TodoWhereUniqueInput] = None,
        include: Optional[types.TodoInclude] = None,
        order: Optional[Union[types.TodoOrderByInput, List[types.TodoOrderByInput]]] = None,
        distinct: Optional[List[types.TodoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Todo record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Todo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Todo model
        order
            Order the returned Todo records by any field
        distinct
            Filter Todo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Todo
            The first Todo record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Todo record ordered by the createdAt field
        todo = Todo.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TodoWhereInput] = None,
        cursor: Optional[types.TodoWhereUniqueInput] = None,
        include: Optional[types.TodoInclude] = None,
        order: Optional[Union[types.TodoOrderByInput, List[types.TodoOrderByInput]]] = None,
        distinct: Optional[List[types.TodoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Todo record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Todo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Todo model
        order
            Order the returned Todo records by any field
        distinct
            Filter Todo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Todo
            The first Todo record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Todo record ordered by the updatedAt field
        todo = Todo.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.TodoUpdateInput,
        where: types.TodoWhereUniqueInput,
        include: Optional[types.TodoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Todo record.

        Parameters
        ----------
        data
            Todo record data specifying what to update
        where
            Todo filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Todo model

        Returns
        -------
        prisma.models.Todo
            The updated Todo record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        todo = Todo.prisma().update(
            where={
                'id': 'cbaaechiej',
            },
            data={
                # data to update the Todo record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.TodoWhereUniqueInput,
        data: types.TodoUpsertInput,
        include: Optional[types.TodoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Todo filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Todo model

        Returns
        -------
        prisma.models.Todo
            The created or updated Todo record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        todo = Todo.prisma().upsert(
            where={
                'id': 'iejbeaaeg',
            },
            data={
                'create': {
                    'id': 'iejbeaaeg',
                    'title': 'fdgjfbhia',
                    'userId': 'jcehcdchh',
                },
                'update': {
                    'title': 'fdgjfbhia',
                    'userId': 'jcehcdchh',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.TodoUpdateManyMutationInput,
        where: types.TodoWhereInput,
    ) -> int:
        """Update multiple Todo records

        Parameters
        ----------
        data
            Todo data to update the selected Todo records to
        where
            Filter to select the Todo records to update

        Returns
        -------
        int
            The total number of Todo records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Todo records
        total = Todo.prisma().update_many(
            data={
                'doneAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TodoWhereInput] = None,
        cursor: Optional[types.TodoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Todo records present in the database

        Parameters
        ----------
        select
            Select the Todo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Todo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TodoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Todo.prisma().count()

        # results: prisma.types.TodoCountAggregateOutput
        results = Todo.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TodoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TodoWhereInput] = None,
        cursor: Optional[types.TodoWhereUniqueInput] = None,
    ) -> types.TodoCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TodoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TodoWhereInput] = None,
        cursor: Optional[types.TodoWhereUniqueInput] = None,
    ) -> Union[int, types.TodoCountAggregateOutput]:
        """Count the number of Todo records present in the database

        Parameters
        ----------
        select
            Select the Todo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Todo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TodoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Todo.prisma().count()

        # results: prisma.types.TodoCountAggregateOutput
        results = Todo.prisma().count(
            select={
                '_all': True,
                'title': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TodoCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TodoWhereInput] = None
    ) -> int:
        """Delete multiple Todo records.

        Parameters
        ----------
        where
            Optional Todo filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Todo records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Todo records
        total = Todo.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TodoScalarFieldKeys'],
        *,
        where: Optional['types.TodoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TodoAvgAggregateInput'] = None,
        sum: Optional['types.TodoSumAggregateInput'] = None,
        min: Optional['types.TodoMinAggregateInput'] = None,
        max: Optional['types.TodoMaxAggregateInput'] = None,
        having: Optional['types.TodoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TodoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TodoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TodoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TodoGroupByOutput']:
        """Group Todo records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Todo fields to group records by
        where
            Todo filter to select records
        take
            Limit the maximum number of Todo records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TodoGroupByOutput]
            A list of dictionaries representing the Todo record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Todo records by userId values
        # and count how many records are in each group
        results = Todo.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class QuestionarioProntidaoAvaliacaoFisicaActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.QuestionarioProntidaoAvaliacaoFisica]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = QuestionarioProntidaoAvaliacaoFisica.prisma().query_raw(
            'SELECT * FROM QuestionarioProntidaoAvaliacaoFisica WHERE id = $1',
            'jcibfcbhf',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = QuestionarioProntidaoAvaliacaoFisica.prisma().query_first(
            'SELECT * FROM QuestionarioProntidaoAvaliacaoFisica WHERE aluno = $1',
            'chdadcaga',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.QuestionarioProntidaoAvaliacaoFisicaCreateInput,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None
    ) -> _PrismaModelT:
        """Create a new QuestionarioProntidaoAvaliacaoFisica record.

        Parameters
        ----------
        data
            QuestionarioProntidaoAvaliacaoFisica record data
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The created QuestionarioProntidaoAvaliacaoFisica record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a QuestionarioProntidaoAvaliacaoFisica record from just the required fields
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().create(
            data={
                # data to create a QuestionarioProntidaoAvaliacaoFisica record
                'aluno': 'jicieifbh',
                'userId': 'fbahdheji',
                'sexo': 'cbbheiicgh',
                'treinador': 'beabjeejdg',
                'dataNascimento': 'bcjhgahffd',
                'Objetivo': 'fbjeiiffa',
                'tempoTreinamentoIninterruptoAtual': 'jhgidcgbf',
                'tempoDestreinamento': 'bgjgecfejc',
                'experienciaPreviaTreinamento': 'bgjcgchib',
                'frequenciaMusculacao': 'bacdaibgfa',
                'modalidadeExtra': 'dchgibach',
                'frequenciaModalidadeExtra': 'fchheijjc',
                'altura': 2029357497.131859,
                'peso': 2122112351.102494,
                'torax': 1717307509.159812,
                'cintura': 817623163.103055,
                'abdomen': 1131525873.21066,
                'quadril': 1276057943.74556,
                'braco_d': 307876141.167404,
                'braco_e': 1526854643.95807,
                'coxa_d': 1513050921.20467,
                'coxa_e': 2067651663.118391,
                'panturrilha_d': 1589704933.124347,
                'panturrilha_e': 1369828971.167859,
                'medidaMao': 403521121.64876,
                'mobilidadeGlenoumeralDireita': 607323719.146889,
                'mobilidadeGlenoumeralEsquerda': 629039005.121416,
                'AmplitudeMovimentoQuadrilDireito': 898613219.65837,
                'AmplitudeMovimentoQuadrilEsquerdo': 954620057.121480,
                'AmplitudeMovimentoTornozeloDireito': 1047820095.130273,
                'AmplitudeMovimentoTornozeloEsquerdo': 893052245.28008,
                'pranchaVentral': 549668955.7679,
                'extensaoColuna': 2098299345.24590,
                'pranchaLateralDireita': 811863863.138880,
                'pranchaLateralEsquerda': 752577037.118766,
                'squatJump1': 769681363.121429,
                'squatJump2': 1021417993.35150,
                'squatJump3': 1321184815.36973,
                'RMagachamento': 1191235013.62756,
                'RMsupino': 1872952907.179328,
                'RMterra': 1814397249.192309,
                'RMbarraFixa': 1277244455.116085,
                'VelocidadeAerobiaMaxima': 361230461.140651,
                'bracoDireito': 1482877891.56662,
                'bracoEsquerdo': 229119865.175001,
                'coxaDireita': 410943775.90902,
                'coxaEsquerda': 755610165.180218,
                'panturrilhaDireita': 294916155.56407,
                'panturrilhaEsquerda': 380648625.103061,
                'idade': 816411927,
                'data': 'baieajjiee',
                'hora': 'bahjhaccfd',
                'pontuacaoTempoTreinoAtual': 755750178,
                'pontuacao_tempo_de_destreinamento_atual': 1128680371,
                'pontuacao_experiencia_previa_de_treinamento': 259061104,
                'pontuacao_media_nivel_treinamento': 1115738345.130378,
                'status_de_treinamento': 'bfhdjaiejf',
                'nivel_mob_torn_direito': 'bbjfijjadg',
                'nivel_mob_torn_esquerdo': 'hdjacbehh',
                'nivel_mob_quadril_direito': 'bhcccbeaba',
                'nivel_mob_quadril_esquerdo': 'bcgjbdgjdj',
                'nivel_mob_omb_direito': 'fhdbhifae',
                'nivel_mob_omb_esquerdo': 'beeacgfcej',
                'nivelPranchaVentral': 'bbifhdiicc',
                'nivelExtensaoColuna': 'bgjeccejad',
                'nivelPranchaLateralDireita': 'bjagdgabbg',
                'nivelPranchaLateralEsquerda': 'bjbbcffdij',
                'pontosPranchaVentral': 146262738.171924,
                'pontosExtensaoColuna': 1948555936.138325,
                'pontosPranchaLateralDireita': 354664990.64716,
                'pontosPranchaLateralEsquerda': 357089484.61239,
                'forcaRelativaAgachamento': 1808130602.115174,
                'forcaRelativaSupino': 78060984.44498,
                'forcaRelativaTerra': 45610742.76908,
                'forcaRelativaBarraFixa': 1334599012.111676,
                'squat_nivel': 'bbhcgagaic',
                'supino_nivel': 'ddaabegbb',
                'terra_nivel': 'bhgibfgbbc',
                'pontuacao_squat_nivel': 71628745.5576,
                'pontuacao_supino_nivel': 812032495.132356,
                'pontuacao_terra_nivel': 43796357.134553,
                'media_squat_jump': 1965387275.80487,
                'vo2_estimado': 1566496513.85000,
                'faixa_etaria': 'cbajdjjabf',
                'nivel_vo2': 'bcicggedea',
                'IMC': 241230397.47586,
                'ClassificacaoIMC': 'bhbgccijjf',
                'idtagaluno': 'bigjhdgbjc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.QuestionarioProntidaoAvaliacaoFisicaCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple QuestionarioProntidaoAvaliacaoFisica records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of QuestionarioProntidaoAvaliacaoFisica record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = QuestionarioProntidaoAvaliacaoFisica.prisma().create_many(
            data=[
                {
                    # data to create a QuestionarioProntidaoAvaliacaoFisica record
                    'aluno': 'bfifdebhfd',
                    'userId': 'cjchbjde',
                    'sexo': 'bfiibjcehj',
                    'treinador': 'ijieafghg',
                    'dataNascimento': 'hhhegahcf',
                    'Objetivo': 'edhijefdi',
                    'tempoTreinamentoIninterruptoAtual': 'djddecjhb',
                    'tempoDestreinamento': 'bgdicjhie',
                    'experienciaPreviaTreinamento': 'ceibfcgij',
                    'frequenciaMusculacao': 'debhbfada',
                    'modalidadeExtra': 'bgjchggecd',
                    'frequenciaModalidadeExtra': 'igggcfjg',
                    'altura': 1697895597.128637,
                    'peso': 864576371.49188,
                    'torax': 392564393.131923,
                    'cintura': 712754127.129955,
                    'abdomen': 2070408293.81190,
                    'quadril': 396021227.64444,
                    'braco_d': 116386273.30928,
                    'braco_e': 22437319.190019,
                    'coxa_d': 2057323293.134411,
                    'coxa_e': 2052132707.135514,
                    'panturrilha_d': 84079641.75443,
                    'panturrilha_e': 314261183.22767,
                    'medidaMao': 423999701.18027,
                    'mobilidadeGlenoumeralDireita': 57608155.203091,
                    'mobilidadeGlenoumeralEsquerda': 1974865233.194986,
                    'AmplitudeMovimentoQuadrilDireito': 1858881207.31981,
                    'AmplitudeMovimentoQuadrilEsquerdo': 368913805.14650,
                    'AmplitudeMovimentoTornozeloDireito': 1398052691.158242,
                    'AmplitudeMovimentoTornozeloEsquerdo': 219944329.34361,
                    'pranchaVentral': 201807279.26142,
                    'extensaoColuna': 52920645.163704,
                    'pranchaLateralDireita': 2055052747.5991,
                    'pranchaLateralEsquerda': 1388571841.23204,
                    'squatJump1': 918965159.66514,
                    'squatJump2': 39949309.190115,
                    'squatJump3': 1627519811.109422,
                    'RMagachamento': 356020985.163833,
                    'RMsupino': 1891567775.107277,
                    'RMterra': 1879328181.157791,
                    'RMbarraFixa': 504729531.11084,
                    'VelocidadeAerobiaMaxima': 1300269105.188108,
                    'bracoDireito': 1082354839.145682,
                    'bracoEsquerdo': 2124707437.129878,
                    'coxaDireita': 1065892659.126647,
                    'coxaEsquerda': 1923026025.9584,
                    'panturrilhaDireita': 1895913359.23239,
                    'panturrilhaEsquerda': 1116931621.124302,
                    'idade': 21355947,
                    'data': 'idbcdhbci',
                    'hora': 'bacegehahd',
                    'pontuacaoTempoTreinoAtual': 414348742,
                    'pontuacao_tempo_de_destreinamento_atual': 1090693511,
                    'pontuacao_experiencia_previa_de_treinamento': 1664319668,
                    'pontuacao_media_nivel_treinamento': 761058525.149842,
                    'status_de_treinamento': 'bjgacaeagh',
                    'nivel_mob_torn_direito': 'beeaihbefg',
                    'nivel_mob_torn_esquerdo': 'bfbfgeddfd',
                    'nivel_mob_quadril_direito': 'jbgheibja',
                    'nivel_mob_quadril_esquerdo': 'eejajbid',
                    'nivel_mob_omb_direito': 'efhdcdaie',
                    'nivel_mob_omb_esquerdo': 'cadejecgbd',
                    'nivelPranchaVentral': 'bahjhjjhcc',
                    'nivelExtensaoColuna': 'ebhbhbdff',
                    'nivelPranchaLateralDireita': 'bdiefcdfhg',
                    'nivelPranchaLateralEsquerda': 'cheifeghd',
                    'pontosPranchaVentral': 568974454.72161,
                    'pontosExtensaoColuna': 1511161572.8189,
                    'pontosPranchaLateralDireita': 2047822338.162079,
                    'pontosPranchaLateralEsquerda': 1877648720.136150,
                    'forcaRelativaAgachamento': 522978382.136536,
                    'forcaRelativaSupino': 1826408060.50977,
                    'forcaRelativaTerra': 1548228442.72846,
                    'forcaRelativaBarraFixa': 107859560.104154,
                    'squat_nivel': 'bjchdacjfa',
                    'supino_nivel': 'fcadcaihb',
                    'terra_nivel': 'bbdcibggga',
                    'pontuacao_squat_nivel': 1061815741.183620,
                    'pontuacao_supino_nivel': 742793987.26594,
                    'pontuacao_terra_nivel': 462831801.24799,
                    'media_squat_jump': 780004447.43809,
                    'vo2_estimado': 936456053.177871,
                    'faixa_etaria': 'bajegedfhj',
                    'nivel_vo2': 'bhfjihjfhg',
                    'IMC': 882003441.186966,
                    'ClassificacaoIMC': 'bfdbbbjhad',
                    'idtagaluno': 'bdibjhdici',
                },
                {
                    # data to create a QuestionarioProntidaoAvaliacaoFisica record
                    'aluno': 'bceigehcbd',
                    'userId': 'caehahihfe',
                    'sexo': 'jjacdhech',
                    'treinador': 'bbbjadabjc',
                    'dataNascimento': 'hhaechedd',
                    'Objetivo': 'gjjgegdic',
                    'tempoTreinamentoIninterruptoAtual': 'bijbiccd',
                    'tempoDestreinamento': 'cbaagdieci',
                    'experienciaPreviaTreinamento': 'jchifaegj',
                    'frequenciaMusculacao': 'dhhdhfebi',
                    'modalidadeExtra': 'decchddih',
                    'frequenciaModalidadeExtra': 'bbegbdehci',
                    'altura': 1241617761.67465,
                    'peso': 734049607.33888,
                    'torax': 937502365.52110,
                    'cintura': 432627427.154722,
                    'abdomen': 472813465.41798,
                    'quadril': 908658239.166258,
                    'braco_d': 1783598165.52630,
                    'braco_e': 11650907.110426,
                    'coxa_d': 743020753.17694,
                    'coxa_e': 1513848375.55913,
                    'panturrilha_d': 754839821.115132,
                    'panturrilha_e': 1866450643.65314,
                    'medidaMao': 170234121.97554,
                    'mobilidadeGlenoumeralDireita': 808844591.99793,
                    'mobilidadeGlenoumeralEsquerda': 1779250373.5149,
                    'AmplitudeMovimentoQuadrilDireito': 1940864331.42442,
                    'AmplitudeMovimentoQuadrilEsquerdo': 1360091201.27764,
                    'AmplitudeMovimentoTornozeloDireito': 506618663.128898,
                    'AmplitudeMovimentoTornozeloEsquerdo': 1390032765.180354,
                    'pranchaVentral': 1809320643.33699,
                    'extensaoColuna': 458739321.134020,
                    'pranchaLateralDireita': 933662751.122152,
                    'pranchaLateralEsquerda': 192796981.81800,
                    'squatJump1': 1554911035.109698,
                    'squatJump2': 1707070385.189708,
                    'squatJump3': 216294423.141818,
                    'RMagachamento': 1179449837.156413,
                    'RMsupino': 968960691.180695,
                    'RMterra': 1661749225.82796,
                    'RMbarraFixa': 1788460815.134683,
                    'VelocidadeAerobiaMaxima': 1331198373.94543,
                    'bracoDireito': 482164011.52797,
                    'bracoEsquerdo': 1065093921.133765,
                    'coxaDireita': 156270855.28529,
                    'coxaEsquerda': 132986973.154530,
                    'panturrilhaDireita': 1827284643.208943,
                    'panturrilhaEsquerda': 1414135129.205574,
                    'idade': 753830399,
                    'data': 'bcdiiadeae',
                    'hora': 'bdhhaeiaif',
                    'pontuacaoTempoTreinoAtual': 2055601450,
                    'pontuacao_tempo_de_destreinamento_atual': 1990969115,
                    'pontuacao_experiencia_previa_de_treinamento': 934293688,
                    'pontuacao_media_nivel_treinamento': 1261239953.182653,
                    'status_de_treinamento': 'ihfjdgceh',
                    'nivel_mob_torn_direito': 'gdaedbiee',
                    'nivel_mob_torn_esquerdo': 'bibdbbffjh',
                    'nivel_mob_quadril_direito': 'bdjfefjjha',
                    'nivel_mob_quadril_esquerdo': 'bjcjfbafeh',
                    'nivel_mob_omb_direito': 'bchgjchgjg',
                    'nivel_mob_omb_esquerdo': 'idgcdejfd',
                    'nivelPranchaVentral': 'baajcgbaag',
                    'nivelExtensaoColuna': 'eahbafhhf',
                    'nivelPranchaLateralDireita': 'chbgcaajc',
                    'nivelPranchaLateralEsquerda': 'baafadjcdh',
                    'pontosPranchaVentral': 1487930586.213127,
                    'pontosExtensaoColuna': 1559050216.210512,
                    'pontosPranchaLateralDireita': 1436128422.154475,
                    'pontosPranchaLateralEsquerda': 810674836.18154,
                    'forcaRelativaAgachamento': 104486194.5817,
                    'forcaRelativaSupino': 1185750016.211793,
                    'forcaRelativaTerra': 733254270.181147,
                    'forcaRelativaBarraFixa': 281540652.81856,
                    'squat_nivel': 'bgjehbiaja',
                    'supino_nivel': 'cadgbfjjf',
                    'terra_nivel': 'bgceeachbc',
                    'pontuacao_squat_nivel': 1120475505.33177,
                    'pontuacao_supino_nivel': 1831305175.204781,
                    'pontuacao_terra_nivel': 805624749.110404,
                    'media_squat_jump': 259670643.186643,
                    'vo2_estimado': 1807779241.139936,
                    'faixa_etaria': 'cbaaahdbgh',
                    'nivel_vo2': 'cahhcbdhii',
                    'IMC': 1081267045.30900,
                    'ClassificacaoIMC': 'gdibgabah',
                    'idtagaluno': 'bbdgidjcea',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single QuestionarioProntidaoAvaliacaoFisica record.

        Parameters
        ----------
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The deleted QuestionarioProntidaoAvaliacaoFisica record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().delete(
            where={
                'id': 'bigggbcjgb',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique QuestionarioProntidaoAvaliacaoFisica record.

        Parameters
        ----------
        where
            QuestionarioProntidaoAvaliacaoFisica filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The found QuestionarioProntidaoAvaliacaoFisica record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().find_unique(
            where={
                'id': 'bfhhaicdhe',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None
    ) -> _PrismaModelT:
        """Find a unique QuestionarioProntidaoAvaliacaoFisica record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            QuestionarioProntidaoAvaliacaoFisica filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The found QuestionarioProntidaoAvaliacaoFisica record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().find_unique_or_raise(
            where={
                'id': 'bgdeigedch',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput] = None,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None,
        order: Optional[Union[types.QuestionarioProntidaoAvaliacaoFisicaOrderByInput, List[types.QuestionarioProntidaoAvaliacaoFisicaOrderByInput]]] = None,
        distinct: Optional[List[types.QuestionarioProntidaoAvaliacaoFisicaScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple QuestionarioProntidaoAvaliacaoFisica records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of QuestionarioProntidaoAvaliacaoFisica records returned
        skip
            Ignore the first N results
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model
        order
            Order the returned QuestionarioProntidaoAvaliacaoFisica records by any field
        distinct
            Filter QuestionarioProntidaoAvaliacaoFisica records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.QuestionarioProntidaoAvaliacaoFisica]
            The list of all QuestionarioProntidaoAvaliacaoFisica records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 QuestionarioProntidaoAvaliacaoFisica records
        questionarioprontidaoavaliacaofisicas = QuestionarioProntidaoAvaliacaoFisica.prisma().find_many(take=10)

        # find the first 5 QuestionarioProntidaoAvaliacaoFisica records ordered by the userId field
        questionarioprontidaoavaliacaofisicas = QuestionarioProntidaoAvaliacaoFisica.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput] = None,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None,
        order: Optional[Union[types.QuestionarioProntidaoAvaliacaoFisicaOrderByInput, List[types.QuestionarioProntidaoAvaliacaoFisicaOrderByInput]]] = None,
        distinct: Optional[List[types.QuestionarioProntidaoAvaliacaoFisicaScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single QuestionarioProntidaoAvaliacaoFisica record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model
        order
            Order the returned QuestionarioProntidaoAvaliacaoFisica records by any field
        distinct
            Filter QuestionarioProntidaoAvaliacaoFisica records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The first QuestionarioProntidaoAvaliacaoFisica record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second QuestionarioProntidaoAvaliacaoFisica record ordered by the sexo field
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().find_first(
            skip=1,
            order={
                'sexo': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput] = None,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None,
        order: Optional[Union[types.QuestionarioProntidaoAvaliacaoFisicaOrderByInput, List[types.QuestionarioProntidaoAvaliacaoFisicaOrderByInput]]] = None,
        distinct: Optional[List[types.QuestionarioProntidaoAvaliacaoFisicaScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single QuestionarioProntidaoAvaliacaoFisica record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model
        order
            Order the returned QuestionarioProntidaoAvaliacaoFisica records by any field
        distinct
            Filter QuestionarioProntidaoAvaliacaoFisica records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The first QuestionarioProntidaoAvaliacaoFisica record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second QuestionarioProntidaoAvaliacaoFisica record ordered by the treinador field
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().find_first_or_raise(
            skip=1,
            order={
                'treinador': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.QuestionarioProntidaoAvaliacaoFisicaUpdateInput,
        where: types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single QuestionarioProntidaoAvaliacaoFisica record.

        Parameters
        ----------
        data
            QuestionarioProntidaoAvaliacaoFisica record data specifying what to update
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The updated QuestionarioProntidaoAvaliacaoFisica record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().update(
            where={
                'id': 'gedhbbhdc',
            },
            data={
                # data to update the QuestionarioProntidaoAvaliacaoFisica record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput,
        data: types.QuestionarioProntidaoAvaliacaoFisicaUpsertInput,
        include: Optional[types.QuestionarioProntidaoAvaliacaoFisicaInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned QuestionarioProntidaoAvaliacaoFisica model

        Returns
        -------
        prisma.models.QuestionarioProntidaoAvaliacaoFisica
            The created or updated QuestionarioProntidaoAvaliacaoFisica record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        questionarioprontidaoavaliacaofisica = QuestionarioProntidaoAvaliacaoFisica.prisma().upsert(
            where={
                'id': 'bcgcffdgcj',
            },
            data={
                'create': {
                    'id': 'bcgcffdgcj',
                    'aluno': 'bceigehcbd',
                    'userId': 'caehahihfe',
                    'sexo': 'jjacdhech',
                    'treinador': 'bbbjadabjc',
                    'dataNascimento': 'hhaechedd',
                    'Objetivo': 'gjjgegdic',
                    'tempoTreinamentoIninterruptoAtual': 'bijbiccd',
                    'tempoDestreinamento': 'cbaagdieci',
                    'experienciaPreviaTreinamento': 'jchifaegj',
                    'frequenciaMusculacao': 'dhhdhfebi',
                    'modalidadeExtra': 'decchddih',
                    'frequenciaModalidadeExtra': 'bbegbdehci',
                    'altura': 1241617761.67465,
                    'peso': 734049607.33888,
                    'torax': 937502365.52110,
                    'cintura': 432627427.154722,
                    'abdomen': 472813465.41798,
                    'quadril': 908658239.166258,
                    'braco_d': 1783598165.52630,
                    'braco_e': 11650907.110426,
                    'coxa_d': 743020753.17694,
                    'coxa_e': 1513848375.55913,
                    'panturrilha_d': 754839821.115132,
                    'panturrilha_e': 1866450643.65314,
                    'medidaMao': 170234121.97554,
                    'mobilidadeGlenoumeralDireita': 808844591.99793,
                    'mobilidadeGlenoumeralEsquerda': 1779250373.5149,
                    'AmplitudeMovimentoQuadrilDireito': 1940864331.42442,
                    'AmplitudeMovimentoQuadrilEsquerdo': 1360091201.27764,
                    'AmplitudeMovimentoTornozeloDireito': 506618663.128898,
                    'AmplitudeMovimentoTornozeloEsquerdo': 1390032765.180354,
                    'pranchaVentral': 1809320643.33699,
                    'extensaoColuna': 458739321.134020,
                    'pranchaLateralDireita': 933662751.122152,
                    'pranchaLateralEsquerda': 192796981.81800,
                    'squatJump1': 1554911035.109698,
                    'squatJump2': 1707070385.189708,
                    'squatJump3': 216294423.141818,
                    'RMagachamento': 1179449837.156413,
                    'RMsupino': 968960691.180695,
                    'RMterra': 1661749225.82796,
                    'RMbarraFixa': 1788460815.134683,
                    'VelocidadeAerobiaMaxima': 1331198373.94543,
                    'bracoDireito': 482164011.52797,
                    'bracoEsquerdo': 1065093921.133765,
                    'coxaDireita': 156270855.28529,
                    'coxaEsquerda': 132986973.154530,
                    'panturrilhaDireita': 1827284643.208943,
                    'panturrilhaEsquerda': 1414135129.205574,
                    'idade': 753830399,
                    'data': 'bcdiiadeae',
                    'hora': 'bdhhaeiaif',
                    'pontuacaoTempoTreinoAtual': 2055601450,
                    'pontuacao_tempo_de_destreinamento_atual': 1990969115,
                    'pontuacao_experiencia_previa_de_treinamento': 934293688,
                    'pontuacao_media_nivel_treinamento': 1261239953.182653,
                    'status_de_treinamento': 'ihfjdgceh',
                    'nivel_mob_torn_direito': 'gdaedbiee',
                    'nivel_mob_torn_esquerdo': 'bibdbbffjh',
                    'nivel_mob_quadril_direito': 'bdjfefjjha',
                    'nivel_mob_quadril_esquerdo': 'bjcjfbafeh',
                    'nivel_mob_omb_direito': 'bchgjchgjg',
                    'nivel_mob_omb_esquerdo': 'idgcdejfd',
                    'nivelPranchaVentral': 'baajcgbaag',
                    'nivelExtensaoColuna': 'eahbafhhf',
                    'nivelPranchaLateralDireita': 'chbgcaajc',
                    'nivelPranchaLateralEsquerda': 'baafadjcdh',
                    'pontosPranchaVentral': 1487930586.213127,
                    'pontosExtensaoColuna': 1559050216.210512,
                    'pontosPranchaLateralDireita': 1436128422.154475,
                    'pontosPranchaLateralEsquerda': 810674836.18154,
                    'forcaRelativaAgachamento': 104486194.5817,
                    'forcaRelativaSupino': 1185750016.211793,
                    'forcaRelativaTerra': 733254270.181147,
                    'forcaRelativaBarraFixa': 281540652.81856,
                    'squat_nivel': 'bgjehbiaja',
                    'supino_nivel': 'cadgbfjjf',
                    'terra_nivel': 'bgceeachbc',
                    'pontuacao_squat_nivel': 1120475505.33177,
                    'pontuacao_supino_nivel': 1831305175.204781,
                    'pontuacao_terra_nivel': 805624749.110404,
                    'media_squat_jump': 259670643.186643,
                    'vo2_estimado': 1807779241.139936,
                    'faixa_etaria': 'cbaaahdbgh',
                    'nivel_vo2': 'cahhcbdhii',
                    'IMC': 1081267045.30900,
                    'ClassificacaoIMC': 'gdibgabah',
                    'idtagaluno': 'bbdgidjcea',
                },
                'update': {
                    'aluno': 'bceigehcbd',
                    'userId': 'caehahihfe',
                    'sexo': 'jjacdhech',
                    'treinador': 'bbbjadabjc',
                    'dataNascimento': 'hhaechedd',
                    'Objetivo': 'gjjgegdic',
                    'tempoTreinamentoIninterruptoAtual': 'bijbiccd',
                    'tempoDestreinamento': 'cbaagdieci',
                    'experienciaPreviaTreinamento': 'jchifaegj',
                    'frequenciaMusculacao': 'dhhdhfebi',
                    'modalidadeExtra': 'decchddih',
                    'frequenciaModalidadeExtra': 'bbegbdehci',
                    'altura': 1241617761.67465,
                    'peso': 734049607.33888,
                    'torax': 937502365.52110,
                    'cintura': 432627427.154722,
                    'abdomen': 472813465.41798,
                    'quadril': 908658239.166258,
                    'braco_d': 1783598165.52630,
                    'braco_e': 11650907.110426,
                    'coxa_d': 743020753.17694,
                    'coxa_e': 1513848375.55913,
                    'panturrilha_d': 754839821.115132,
                    'panturrilha_e': 1866450643.65314,
                    'medidaMao': 170234121.97554,
                    'mobilidadeGlenoumeralDireita': 808844591.99793,
                    'mobilidadeGlenoumeralEsquerda': 1779250373.5149,
                    'AmplitudeMovimentoQuadrilDireito': 1940864331.42442,
                    'AmplitudeMovimentoQuadrilEsquerdo': 1360091201.27764,
                    'AmplitudeMovimentoTornozeloDireito': 506618663.128898,
                    'AmplitudeMovimentoTornozeloEsquerdo': 1390032765.180354,
                    'pranchaVentral': 1809320643.33699,
                    'extensaoColuna': 458739321.134020,
                    'pranchaLateralDireita': 933662751.122152,
                    'pranchaLateralEsquerda': 192796981.81800,
                    'squatJump1': 1554911035.109698,
                    'squatJump2': 1707070385.189708,
                    'squatJump3': 216294423.141818,
                    'RMagachamento': 1179449837.156413,
                    'RMsupino': 968960691.180695,
                    'RMterra': 1661749225.82796,
                    'RMbarraFixa': 1788460815.134683,
                    'VelocidadeAerobiaMaxima': 1331198373.94543,
                    'bracoDireito': 482164011.52797,
                    'bracoEsquerdo': 1065093921.133765,
                    'coxaDireita': 156270855.28529,
                    'coxaEsquerda': 132986973.154530,
                    'panturrilhaDireita': 1827284643.208943,
                    'panturrilhaEsquerda': 1414135129.205574,
                    'idade': 753830399,
                    'data': 'bcdiiadeae',
                    'hora': 'bdhhaeiaif',
                    'pontuacaoTempoTreinoAtual': 2055601450,
                    'pontuacao_tempo_de_destreinamento_atual': 1990969115,
                    'pontuacao_experiencia_previa_de_treinamento': 934293688,
                    'pontuacao_media_nivel_treinamento': 1261239953.182653,
                    'status_de_treinamento': 'ihfjdgceh',
                    'nivel_mob_torn_direito': 'gdaedbiee',
                    'nivel_mob_torn_esquerdo': 'bibdbbffjh',
                    'nivel_mob_quadril_direito': 'bdjfefjjha',
                    'nivel_mob_quadril_esquerdo': 'bjcjfbafeh',
                    'nivel_mob_omb_direito': 'bchgjchgjg',
                    'nivel_mob_omb_esquerdo': 'idgcdejfd',
                    'nivelPranchaVentral': 'baajcgbaag',
                    'nivelExtensaoColuna': 'eahbafhhf',
                    'nivelPranchaLateralDireita': 'chbgcaajc',
                    'nivelPranchaLateralEsquerda': 'baafadjcdh',
                    'pontosPranchaVentral': 1487930586.213127,
                    'pontosExtensaoColuna': 1559050216.210512,
                    'pontosPranchaLateralDireita': 1436128422.154475,
                    'pontosPranchaLateralEsquerda': 810674836.18154,
                    'forcaRelativaAgachamento': 104486194.5817,
                    'forcaRelativaSupino': 1185750016.211793,
                    'forcaRelativaTerra': 733254270.181147,
                    'forcaRelativaBarraFixa': 281540652.81856,
                    'squat_nivel': 'bgjehbiaja',
                    'supino_nivel': 'cadgbfjjf',
                    'terra_nivel': 'bgceeachbc',
                    'pontuacao_squat_nivel': 1120475505.33177,
                    'pontuacao_supino_nivel': 1831305175.204781,
                    'pontuacao_terra_nivel': 805624749.110404,
                    'media_squat_jump': 259670643.186643,
                    'vo2_estimado': 1807779241.139936,
                    'faixa_etaria': 'cbaaahdbgh',
                    'nivel_vo2': 'cahhcbdhii',
                    'IMC': 1081267045.30900,
                    'ClassificacaoIMC': 'gdibgabah',
                    'idtagaluno': 'bbdgidjcea',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.QuestionarioProntidaoAvaliacaoFisicaUpdateManyMutationInput,
        where: types.QuestionarioProntidaoAvaliacaoFisicaWhereInput,
    ) -> int:
        """Update multiple QuestionarioProntidaoAvaliacaoFisica records

        Parameters
        ----------
        data
            QuestionarioProntidaoAvaliacaoFisica data to update the selected QuestionarioProntidaoAvaliacaoFisica records to
        where
            Filter to select the QuestionarioProntidaoAvaliacaoFisica records to update

        Returns
        -------
        int
            The total number of QuestionarioProntidaoAvaliacaoFisica records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all QuestionarioProntidaoAvaliacaoFisica records
        total = QuestionarioProntidaoAvaliacaoFisica.prisma().update_many(
            data={
                'dataNascimento': 'bihjhiiji'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput] = None,
    ) -> int:
        """Count the number of QuestionarioProntidaoAvaliacaoFisica records present in the database

        Parameters
        ----------
        select
            Select the QuestionarioProntidaoAvaliacaoFisica fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            QuestionarioProntidaoAvaliacaoFisica filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = QuestionarioProntidaoAvaliacaoFisica.prisma().count()

        # results: prisma.types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput
        results = QuestionarioProntidaoAvaliacaoFisica.prisma().count(
            select={
                '_all': True,
                'Objetivo': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput] = None,
    ) -> types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereUniqueInput] = None,
    ) -> Union[int, types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput]:
        """Count the number of QuestionarioProntidaoAvaliacaoFisica records present in the database

        Parameters
        ----------
        select
            Select the QuestionarioProntidaoAvaliacaoFisica fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            QuestionarioProntidaoAvaliacaoFisica filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = QuestionarioProntidaoAvaliacaoFisica.prisma().count()

        # results: prisma.types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput
        results = QuestionarioProntidaoAvaliacaoFisica.prisma().count(
            select={
                '_all': True,
                'tempoTreinamentoIninterruptoAtual': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.QuestionarioProntidaoAvaliacaoFisicaWhereInput] = None
    ) -> int:
        """Delete multiple QuestionarioProntidaoAvaliacaoFisica records.

        Parameters
        ----------
        where
            Optional QuestionarioProntidaoAvaliacaoFisica filter to find the records to be deleted

        Returns
        -------
        int
            The total number of QuestionarioProntidaoAvaliacaoFisica records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all QuestionarioProntidaoAvaliacaoFisica records
        total = QuestionarioProntidaoAvaliacaoFisica.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.QuestionarioProntidaoAvaliacaoFisicaScalarFieldKeys'],
        *,
        where: Optional['types.QuestionarioProntidaoAvaliacaoFisicaWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.QuestionarioProntidaoAvaliacaoFisicaAvgAggregateInput'] = None,
        sum: Optional['types.QuestionarioProntidaoAvaliacaoFisicaSumAggregateInput'] = None,
        min: Optional['types.QuestionarioProntidaoAvaliacaoFisicaMinAggregateInput'] = None,
        max: Optional['types.QuestionarioProntidaoAvaliacaoFisicaMaxAggregateInput'] = None,
        having: Optional['types.QuestionarioProntidaoAvaliacaoFisicaScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.QuestionarioProntidaoAvaliacaoFisicaCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.QuestionarioProntidaoAvaliacaoFisicaScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.QuestionarioProntidaoAvaliacaoFisicaScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.QuestionarioProntidaoAvaliacaoFisicaGroupByOutput']:
        """Group QuestionarioProntidaoAvaliacaoFisica records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar QuestionarioProntidaoAvaliacaoFisica fields to group records by
        where
            QuestionarioProntidaoAvaliacaoFisica filter to select records
        take
            Limit the maximum number of QuestionarioProntidaoAvaliacaoFisica records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.QuestionarioProntidaoAvaliacaoFisicaGroupByOutput]
            A list of dictionaries representing the QuestionarioProntidaoAvaliacaoFisica record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group QuestionarioProntidaoAvaliacaoFisica records by tempoDestreinamento values
        # and count how many records are in each group
        results = QuestionarioProntidaoAvaliacaoFisica.prisma().group_by(
            ['tempoDestreinamento'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FormularioAvaliacaoFisicaActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.FormularioAvaliacaoFisica]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = FormularioAvaliacaoFisica.prisma().query_raw(
            'SELECT * FROM FormularioAvaliacaoFisica WHERE id = $1',
            'ididibbff',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = FormularioAvaliacaoFisica.prisma().query_first(
            'SELECT * FROM FormularioAvaliacaoFisica WHERE userId = $1',
            'cgbfcibga',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.FormularioAvaliacaoFisicaCreateInput,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None
    ) -> _PrismaModelT:
        """Create a new FormularioAvaliacaoFisica record.

        Parameters
        ----------
        data
            FormularioAvaliacaoFisica record data
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The created FormularioAvaliacaoFisica record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FormularioAvaliacaoFisica record from just the required fields
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().create(
            data={
                # data to create a FormularioAvaliacaoFisica record
                'userId': 'bcibjgahcj',
                'aluno': 'bbbbedfcda',
                'treinador': 'gejjhdbid',
                'diaTreino': 'bjfaacchjg',
                'modalidadeTreino': 'beeigdcchh',
                'diaTreinoExtra': 'bgihcicggg',
                'modalidadeTreinoExtra': 'bjiiifffbf',
                'altura': 1692489080.78513,
                'peso': 1201820854.81695,
                'torax': 1670533412.160836,
                'cintura': 1349977666.53070,
                'abdomen': 1748327312.3342,
                'quadril': 1005798542.96125,
                'braco_d': 1069326524.69952,
                'braco_e': 534977434.95996,
                'coxa_d': 839978152.196383,
                'coxa_e': 1892112230.108039,
                'panturrilha_d': 448678740.196200,
                'panturrilha_e': 409043954.38411,
                'medidaMao': 1616824512.184589,
                'mobilidadeGlenoumeralDireita': 1761602878.179864,
                'mobilidadeGlenoumeralEsquerda': 1992798444.76273,
                'AmplitudeMovimentoQuadrilDireito': 2039062346.72755,
                'AmplitudeMovimentoQuadrilEsquerdo': 1475669976.183593,
                'AmplitudeMovimentoTornozeloDireito': 910845462.140590,
                'AmplitudeMovimentoTornozeloEsquerdo': 531968388.8942,
                'pranchaVentral': 847170978.134120,
                'extensaoColuna': 907403760.164053,
                'pranchaLateralDireita': 111157742.121799,
                'pranchaLateralEsquerda': 881798428.609,
                'squatJump1': 1198550778.208113,
                'squatJump2': 1911553800.179648,
                'squatJump3': 1640399046.207862,
                'RMagachamento': 1628046260.187253,
                'RMsupino': 1729749842.182379,
                'RMterra': 773695264.23986,
                'RMbarraFixa': 382657182.59289,
                'VelocidadeAerobiaMaxima': 1191581004.155794,
                'bracoDireito': 809667242.100774,
                'bracoEsquerdo': 975518264.149153,
                'coxaDireita': 1503045494.12474,
                'coxaEsquerda': 403685860.171345,
                'panturrilhaDireita': 658359554.175948,
                'panturrilhaEsquerda': 1140398160.195191,
                'idade': 273100622,
                'data': 'fbbijihb',
                'hora': 'bfjbgjjidg',
                'pontuacaoTempoTreinoAtual': 153870853,
                'pontuacao_tempo_de_destreinamento_atual': 1533735514,
                'pontuacao_experiencia_previa_de_treinamento': 1308413067,
                'pontuacao_media_nivel_treinamento': 964141416.69714,
                'status_de_treinamento': 'bdfgbjccje',
                'nivel_mob_torn_direito': 'bjchjbfbbb',
                'nivel_mob_torn_esquerdo': 'cachfbejaa',
                'nivel_mob_quadril_direito': 'bfjddjgebd',
                'nivel_mob_quadril_esquerdo': 'babifceddi',
                'nivel_mob_omb_direito': 'bgfgjbjah',
                'nivel_mob_omb_esquerdo': 'bfaifigiia',
                'nivelPranchaVentral': 'bebgicaggf',
                'nivelExtensaoColuna': 'cedfddicc',
                'nivelPranchaLateralDireita': 'dfeaijicd',
                'nivelPranchaLateralEsquerda': 'baggcibdii',
                'pontosPranchaVentral': 1195529845.55500,
                'pontosExtensaoColuna': 1444802171.200554,
                'pontosPranchaLateralDireita': 1198449905.200272,
                'pontosPranchaLateralEsquerda': 1486026583.164796,
                'forcaRelativaAgachamento': 66838317.204760,
                'forcaRelativaSupino': 1323676147.176101,
                'forcaRelativaTerra': 518275369.2938,
                'forcaRelativaBarraFixa': 480213583.186681,
                'squat_nivel': 'bbfejcgdaj',
                'supino_nivel': 'jhfihdegg',
                'terra_nivel': 'hbdcfgaed',
                'pontuacao_squat_nivel': 717222856.7876,
                'pontuacao_supino_nivel': 701326214.161758,
                'pontuacao_terra_nivel': 230982772.58300,
                'media_squat_jump': 1787572754.162522,
                'vo2_estimado': 819950560.167266,
                'faixa_etaria': 'bfjdcgjfji',
                'nivel_vo2': 'bgfcbdfcdb',
                'IMC': 1727524364.19085,
                'ClassificacaoIMC': 'biieibbgcg',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.FormularioAvaliacaoFisicaCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FormularioAvaliacaoFisica records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FormularioAvaliacaoFisica record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = FormularioAvaliacaoFisica.prisma().create_many(
            data=[
                {
                    # data to create a FormularioAvaliacaoFisica record
                    'userId': 'bbcdicjddj',
                    'aluno': 'bheihfebgi',
                    'treinador': 'biifjcaib',
                    'diaTreino': 'fgbhfghcg',
                    'modalidadeTreino': 'iaidibhfb',
                    'diaTreinoExtra': 'bahaddafdc',
                    'modalidadeTreinoExtra': 'eiaabgdjh',
                    'altura': 37831618.4162,
                    'peso': 1747424528.111814,
                    'torax': 1340332558.62549,
                    'cintura': 1113125436.188046,
                    'abdomen': 1309116698.68940,
                    'quadril': 1407252008.128720,
                    'braco_d': 612703462.153298,
                    'braco_e': 2002996436.145388,
                    'coxa_d': 1307976050.269,
                    'coxa_e': 1813144128.153115,
                    'panturrilha_d': 1661002430.15798,
                    'panturrilha_e': 1876648556.6592,
                    'medidaMao': 1315204298.174719,
                    'mobilidadeGlenoumeralDireita': 1347565912.192173,
                    'mobilidadeGlenoumeralEsquerda': 902073238.139639,
                    'AmplitudeMovimentoQuadrilDireito': 509448964.70012,
                    'AmplitudeMovimentoQuadrilEsquerdo': 590727970.53844,
                    'AmplitudeMovimentoTornozeloDireito': 1889721200.102050,
                    'AmplitudeMovimentoTornozeloEsquerdo': 998864750.15096,
                    'pranchaVentral': 1622294172.6084,
                    'extensaoColuna': 223976570.210036,
                    'pranchaLateralDireita': 787654792.130622,
                    'pranchaLateralEsquerda': 1154811462.145550,
                    'squatJump1': 961398068.138274,
                    'squatJump2': 1347109074.30557,
                    'squatJump3': 815530144.144894,
                    'RMagachamento': 1098422302.167602,
                    'RMsupino': 953190092.120191,
                    'RMterra': 2006063146.119205,
                    'RMbarraFixa': 1608860600.120062,
                    'VelocidadeAerobiaMaxima': 1578208502.165571,
                    'bracoDireito': 394716004.162840,
                    'bracoEsquerdo': 1279361666.161404,
                    'coxaDireita': 494981584.172221,
                    'coxaEsquerda': 1367950542.26406,
                    'panturrilhaDireita': 2129214204.87550,
                    'panturrilhaEsquerda': 2054741978.198442,
                    'idade': 571280104,
                    'data': 'bdehefecaj',
                    'hora': 'bfbjhcceag',
                    'pontuacaoTempoTreinoAtual': 562511335,
                    'pontuacao_tempo_de_destreinamento_atual': 52161940,
                    'pontuacao_experiencia_previa_de_treinamento': 700411965,
                    'pontuacao_media_nivel_treinamento': 1726189618.156865,
                    'status_de_treinamento': 'cgbdhhhjc',
                    'nivel_mob_torn_direito': 'bibffjhiib',
                    'nivel_mob_torn_esquerdo': 'bidccihgbe',
                    'nivel_mob_quadril_direito': 'ggjcfedgh',
                    'nivel_mob_quadril_esquerdo': 'bcicdggcfc',
                    'nivel_mob_omb_direito': 'gjbgcifdd',
                    'nivel_mob_omb_esquerdo': 'ihgbehfje',
                    'nivelPranchaVentral': 'cbaacjdbbf',
                    'nivelExtensaoColuna': 'ifgeijejg',
                    'nivelPranchaLateralDireita': 'bdfaiahggf',
                    'nivelPranchaLateralEsquerda': 'chccifcha',
                    'pontosPranchaVentral': 1535471319.189372,
                    'pontosExtensaoColuna': 877781677.202561,
                    'pontosPranchaLateralDireita': 390603123.197718,
                    'pontosPranchaLateralEsquerda': 358022313.179065,
                    'forcaRelativaAgachamento': 1568235983.210697,
                    'forcaRelativaSupino': 1920580197.59961,
                    'forcaRelativaTerra': 2144619499.213543,
                    'forcaRelativaBarraFixa': 407934945.2709,
                    'squat_nivel': 'bhccdjjgih',
                    'supino_nivel': 'ibbjhgbia',
                    'terra_nivel': 'heedefiif',
                    'pontuacao_squat_nivel': 320278418.114899,
                    'pontuacao_supino_nivel': 101928288.80605,
                    'pontuacao_terra_nivel': 621974238.173410,
                    'media_squat_jump': 1632624524.92949,
                    'vo2_estimado': 1487994602.114111,
                    'faixa_etaria': 'bdhdhcgiea',
                    'nivel_vo2': 'bddfhgjjdh',
                    'IMC': 236462006.38083,
                    'ClassificacaoIMC': 'egjhjjjhc',
                },
                {
                    # data to create a FormularioAvaliacaoFisica record
                    'userId': 'bdgchhaicj',
                    'aluno': 'iafcaidig',
                    'treinador': 'jacfbiajj',
                    'diaTreino': 'biceidhcge',
                    'modalidadeTreino': 'ediaedfcj',
                    'diaTreinoExtra': 'hdhgdgcdi',
                    'modalidadeTreinoExtra': 'bjbfeidaff',
                    'altura': 1766867900.179885,
                    'peso': 595523226.55876,
                    'torax': 79421352.171256,
                    'cintura': 566616678.75711,
                    'abdomen': 1220759124.171115,
                    'quadril': 1648213746.116839,
                    'braco_d': 2100362176.82312,
                    'braco_e': 1944377406.27309,
                    'coxa_d': 1510609900.102161,
                    'coxa_e': 1163016778.189592,
                    'panturrilha_d': 813335256.5188,
                    'panturrilha_e': 1702998294.122796,
                    'medidaMao': 914420868.56207,
                    'mobilidadeGlenoumeralDireita': 90163362.121149,
                    'mobilidadeGlenoumeralEsquerda': 1633342704.111030,
                    'AmplitudeMovimentoQuadrilDireito': 102092014.70129,
                    'AmplitudeMovimentoQuadrilEsquerdo': 2058375196.11972,
                    'AmplitudeMovimentoTornozeloDireito': 538298874.211690,
                    'AmplitudeMovimentoTornozeloEsquerdo': 1551913480.197666,
                    'pranchaVentral': 1860602822.147456,
                    'extensaoColuna': 2144110260.50910,
                    'pranchaLateralDireita': 1840225874.207091,
                    'pranchaLateralEsquerda': 1241864736.205503,
                    'squatJump1': 814042526.182218,
                    'squatJump2': 1161164876.108069,
                    'squatJump3': 1718920618.197345,
                    'RMagachamento': 787500344.62338,
                    'RMsupino': 1884254838.6657,
                    'RMterra': 167314660.125598,
                    'RMbarraFixa': 406339586.199649,
                    'VelocidadeAerobiaMaxima': 515083088.145574,
                    'bracoDireito': 904813134.101216,
                    'bracoEsquerdo': 374213756.179419,
                    'coxaDireita': 1272565082.144140,
                    'coxaEsquerda': 481129576.214344,
                    'panturrilhaDireita': 1758946598.63621,
                    'panturrilhaEsquerda': 890859284.149556,
                    'idade': 1522838962,
                    'data': 'ehfeccjhj',
                    'hora': 'hggabbfca',
                    'pontuacaoTempoTreinoAtual': 327921337,
                    'pontuacao_tempo_de_destreinamento_atual': 2110518014,
                    'pontuacao_experiencia_previa_de_treinamento': 575933023,
                    'pontuacao_media_nivel_treinamento': 1567329452.7860,
                    'status_de_treinamento': 'ihjhhbjbe',
                    'nivel_mob_torn_direito': 'bfjjggdeid',
                    'nivel_mob_torn_esquerdo': 'ecfdhjhdg',
                    'nivel_mob_quadril_direito': 'bibcecjiaj',
                    'nivel_mob_quadril_esquerdo': 'bebfbeeeag',
                    'nivel_mob_omb_direito': 'ihcdedbch',
                    'nivel_mob_omb_esquerdo': 'cabdhhajc',
                    'nivelPranchaVentral': 'hiijibcjd',
                    'nivelExtensaoColuna': 'dddeeaigg',
                    'nivelPranchaLateralDireita': 'bbbcfbgjj',
                    'nivelPranchaLateralEsquerda': 'bfebigbiai',
                    'pontosPranchaVentral': 488159273.114668,
                    'pontosExtensaoColuna': 1035618639.128774,
                    'pontosPranchaLateralDireita': 2002496997.169679,
                    'pontosPranchaLateralEsquerda': 66857835.119716,
                    'forcaRelativaAgachamento': 941507425.153409,
                    'forcaRelativaSupino': 842011463.195048,
                    'forcaRelativaTerra': 1444590749.152390,
                    'forcaRelativaBarraFixa': 2060492003.142935,
                    'squat_nivel': 'cbdicecefh',
                    'supino_nivel': 'bcfbaacegc',
                    'terra_nivel': 'igcddbjgh',
                    'pontuacao_squat_nivel': 155373836.14135,
                    'pontuacao_supino_nivel': 865930346.147028,
                    'pontuacao_terra_nivel': 668070392.16657,
                    'media_squat_jump': 58164534.57451,
                    'vo2_estimado': 1580217764.180715,
                    'faixa_etaria': 'hjjjibcfa',
                    'nivel_vo2': 'begjccaafb',
                    'IMC': 1007486992.144923,
                    'ClassificacaoIMC': 'badghjceg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.FormularioAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FormularioAvaliacaoFisica record.

        Parameters
        ----------
        where
            FormularioAvaliacaoFisica filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The deleted FormularioAvaliacaoFisica record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().delete(
            where={
                'id': 'fachaaieh',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.FormularioAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FormularioAvaliacaoFisica record.

        Parameters
        ----------
        where
            FormularioAvaliacaoFisica filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The found FormularioAvaliacaoFisica record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().find_unique(
            where={
                'id': 'bfcagaeehg',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.FormularioAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FormularioAvaliacaoFisica record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FormularioAvaliacaoFisica filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The found FormularioAvaliacaoFisica record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().find_unique_or_raise(
            where={
                'id': 'bccgeebebd',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.FormularioAvaliacaoFisicaWhereUniqueInput] = None,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None,
        order: Optional[Union[types.FormularioAvaliacaoFisicaOrderByInput, List[types.FormularioAvaliacaoFisicaOrderByInput]]] = None,
        distinct: Optional[List[types.FormularioAvaliacaoFisicaScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FormularioAvaliacaoFisica records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FormularioAvaliacaoFisica records returned
        skip
            Ignore the first N results
        where
            FormularioAvaliacaoFisica filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model
        order
            Order the returned FormularioAvaliacaoFisica records by any field
        distinct
            Filter FormularioAvaliacaoFisica records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FormularioAvaliacaoFisica]
            The list of all FormularioAvaliacaoFisica records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FormularioAvaliacaoFisica records
        formularioavaliacaofisicas = FormularioAvaliacaoFisica.prisma().find_many(take=10)

        # find the first 5 FormularioAvaliacaoFisica records ordered by the aluno field
        formularioavaliacaofisicas = FormularioAvaliacaoFisica.prisma().find_many(
            take=5,
            order={
                'aluno': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.FormularioAvaliacaoFisicaWhereUniqueInput] = None,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None,
        order: Optional[Union[types.FormularioAvaliacaoFisicaOrderByInput, List[types.FormularioAvaliacaoFisicaOrderByInput]]] = None,
        distinct: Optional[List[types.FormularioAvaliacaoFisicaScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FormularioAvaliacaoFisica record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FormularioAvaliacaoFisica filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model
        order
            Order the returned FormularioAvaliacaoFisica records by any field
        distinct
            Filter FormularioAvaliacaoFisica records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The first FormularioAvaliacaoFisica record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FormularioAvaliacaoFisica record ordered by the treinador field
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().find_first(
            skip=1,
            order={
                'treinador': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.FormularioAvaliacaoFisicaWhereUniqueInput] = None,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None,
        order: Optional[Union[types.FormularioAvaliacaoFisicaOrderByInput, List[types.FormularioAvaliacaoFisicaOrderByInput]]] = None,
        distinct: Optional[List[types.FormularioAvaliacaoFisicaScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FormularioAvaliacaoFisica record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FormularioAvaliacaoFisica filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model
        order
            Order the returned FormularioAvaliacaoFisica records by any field
        distinct
            Filter FormularioAvaliacaoFisica records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The first FormularioAvaliacaoFisica record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FormularioAvaliacaoFisica record ordered by the diaTreino field
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().find_first_or_raise(
            skip=1,
            order={
                'diaTreino': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.FormularioAvaliacaoFisicaUpdateInput,
        where: types.FormularioAvaliacaoFisicaWhereUniqueInput,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FormularioAvaliacaoFisica record.

        Parameters
        ----------
        data
            FormularioAvaliacaoFisica record data specifying what to update
        where
            FormularioAvaliacaoFisica filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The updated FormularioAvaliacaoFisica record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().update(
            where={
                'id': 'jbahhjebi',
            },
            data={
                # data to update the FormularioAvaliacaoFisica record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.FormularioAvaliacaoFisicaWhereUniqueInput,
        data: types.FormularioAvaliacaoFisicaUpsertInput,
        include: Optional[types.FormularioAvaliacaoFisicaInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FormularioAvaliacaoFisica filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FormularioAvaliacaoFisica model

        Returns
        -------
        prisma.models.FormularioAvaliacaoFisica
            The created or updated FormularioAvaliacaoFisica record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        formularioavaliacaofisica = FormularioAvaliacaoFisica.prisma().upsert(
            where={
                'id': 'cbefbaghgd',
            },
            data={
                'create': {
                    'id': 'cbefbaghgd',
                    'userId': 'bdgchhaicj',
                    'aluno': 'iafcaidig',
                    'treinador': 'jacfbiajj',
                    'diaTreino': 'biceidhcge',
                    'modalidadeTreino': 'ediaedfcj',
                    'diaTreinoExtra': 'hdhgdgcdi',
                    'modalidadeTreinoExtra': 'bjbfeidaff',
                    'altura': 1766867900.179885,
                    'peso': 595523226.55876,
                    'torax': 79421352.171256,
                    'cintura': 566616678.75711,
                    'abdomen': 1220759124.171115,
                    'quadril': 1648213746.116839,
                    'braco_d': 2100362176.82312,
                    'braco_e': 1944377406.27309,
                    'coxa_d': 1510609900.102161,
                    'coxa_e': 1163016778.189592,
                    'panturrilha_d': 813335256.5188,
                    'panturrilha_e': 1702998294.122796,
                    'medidaMao': 914420868.56207,
                    'mobilidadeGlenoumeralDireita': 90163362.121149,
                    'mobilidadeGlenoumeralEsquerda': 1633342704.111030,
                    'AmplitudeMovimentoQuadrilDireito': 102092014.70129,
                    'AmplitudeMovimentoQuadrilEsquerdo': 2058375196.11972,
                    'AmplitudeMovimentoTornozeloDireito': 538298874.211690,
                    'AmplitudeMovimentoTornozeloEsquerdo': 1551913480.197666,
                    'pranchaVentral': 1860602822.147456,
                    'extensaoColuna': 2144110260.50910,
                    'pranchaLateralDireita': 1840225874.207091,
                    'pranchaLateralEsquerda': 1241864736.205503,
                    'squatJump1': 814042526.182218,
                    'squatJump2': 1161164876.108069,
                    'squatJump3': 1718920618.197345,
                    'RMagachamento': 787500344.62338,
                    'RMsupino': 1884254838.6657,
                    'RMterra': 167314660.125598,
                    'RMbarraFixa': 406339586.199649,
                    'VelocidadeAerobiaMaxima': 515083088.145574,
                    'bracoDireito': 904813134.101216,
                    'bracoEsquerdo': 374213756.179419,
                    'coxaDireita': 1272565082.144140,
                    'coxaEsquerda': 481129576.214344,
                    'panturrilhaDireita': 1758946598.63621,
                    'panturrilhaEsquerda': 890859284.149556,
                    'idade': 1522838962,
                    'data': 'ehfeccjhj',
                    'hora': 'hggabbfca',
                    'pontuacaoTempoTreinoAtual': 327921337,
                    'pontuacao_tempo_de_destreinamento_atual': 2110518014,
                    'pontuacao_experiencia_previa_de_treinamento': 575933023,
                    'pontuacao_media_nivel_treinamento': 1567329452.7860,
                    'status_de_treinamento': 'ihjhhbjbe',
                    'nivel_mob_torn_direito': 'bfjjggdeid',
                    'nivel_mob_torn_esquerdo': 'ecfdhjhdg',
                    'nivel_mob_quadril_direito': 'bibcecjiaj',
                    'nivel_mob_quadril_esquerdo': 'bebfbeeeag',
                    'nivel_mob_omb_direito': 'ihcdedbch',
                    'nivel_mob_omb_esquerdo': 'cabdhhajc',
                    'nivelPranchaVentral': 'hiijibcjd',
                    'nivelExtensaoColuna': 'dddeeaigg',
                    'nivelPranchaLateralDireita': 'bbbcfbgjj',
                    'nivelPranchaLateralEsquerda': 'bfebigbiai',
                    'pontosPranchaVentral': 488159273.114668,
                    'pontosExtensaoColuna': 1035618639.128774,
                    'pontosPranchaLateralDireita': 2002496997.169679,
                    'pontosPranchaLateralEsquerda': 66857835.119716,
                    'forcaRelativaAgachamento': 941507425.153409,
                    'forcaRelativaSupino': 842011463.195048,
                    'forcaRelativaTerra': 1444590749.152390,
                    'forcaRelativaBarraFixa': 2060492003.142935,
                    'squat_nivel': 'cbdicecefh',
                    'supino_nivel': 'bcfbaacegc',
                    'terra_nivel': 'igcddbjgh',
                    'pontuacao_squat_nivel': 155373836.14135,
                    'pontuacao_supino_nivel': 865930346.147028,
                    'pontuacao_terra_nivel': 668070392.16657,
                    'media_squat_jump': 58164534.57451,
                    'vo2_estimado': 1580217764.180715,
                    'faixa_etaria': 'hjjjibcfa',
                    'nivel_vo2': 'begjccaafb',
                    'IMC': 1007486992.144923,
                    'ClassificacaoIMC': 'badghjceg',
                },
                'update': {
                    'userId': 'bdgchhaicj',
                    'aluno': 'iafcaidig',
                    'treinador': 'jacfbiajj',
                    'diaTreino': 'biceidhcge',
                    'modalidadeTreino': 'ediaedfcj',
                    'diaTreinoExtra': 'hdhgdgcdi',
                    'modalidadeTreinoExtra': 'bjbfeidaff',
                    'altura': 1766867900.179885,
                    'peso': 595523226.55876,
                    'torax': 79421352.171256,
                    'cintura': 566616678.75711,
                    'abdomen': 1220759124.171115,
                    'quadril': 1648213746.116839,
                    'braco_d': 2100362176.82312,
                    'braco_e': 1944377406.27309,
                    'coxa_d': 1510609900.102161,
                    'coxa_e': 1163016778.189592,
                    'panturrilha_d': 813335256.5188,
                    'panturrilha_e': 1702998294.122796,
                    'medidaMao': 914420868.56207,
                    'mobilidadeGlenoumeralDireita': 90163362.121149,
                    'mobilidadeGlenoumeralEsquerda': 1633342704.111030,
                    'AmplitudeMovimentoQuadrilDireito': 102092014.70129,
                    'AmplitudeMovimentoQuadrilEsquerdo': 2058375196.11972,
                    'AmplitudeMovimentoTornozeloDireito': 538298874.211690,
                    'AmplitudeMovimentoTornozeloEsquerdo': 1551913480.197666,
                    'pranchaVentral': 1860602822.147456,
                    'extensaoColuna': 2144110260.50910,
                    'pranchaLateralDireita': 1840225874.207091,
                    'pranchaLateralEsquerda': 1241864736.205503,
                    'squatJump1': 814042526.182218,
                    'squatJump2': 1161164876.108069,
                    'squatJump3': 1718920618.197345,
                    'RMagachamento': 787500344.62338,
                    'RMsupino': 1884254838.6657,
                    'RMterra': 167314660.125598,
                    'RMbarraFixa': 406339586.199649,
                    'VelocidadeAerobiaMaxima': 515083088.145574,
                    'bracoDireito': 904813134.101216,
                    'bracoEsquerdo': 374213756.179419,
                    'coxaDireita': 1272565082.144140,
                    'coxaEsquerda': 481129576.214344,
                    'panturrilhaDireita': 1758946598.63621,
                    'panturrilhaEsquerda': 890859284.149556,
                    'idade': 1522838962,
                    'data': 'ehfeccjhj',
                    'hora': 'hggabbfca',
                    'pontuacaoTempoTreinoAtual': 327921337,
                    'pontuacao_tempo_de_destreinamento_atual': 2110518014,
                    'pontuacao_experiencia_previa_de_treinamento': 575933023,
                    'pontuacao_media_nivel_treinamento': 1567329452.7860,
                    'status_de_treinamento': 'ihjhhbjbe',
                    'nivel_mob_torn_direito': 'bfjjggdeid',
                    'nivel_mob_torn_esquerdo': 'ecfdhjhdg',
                    'nivel_mob_quadril_direito': 'bibcecjiaj',
                    'nivel_mob_quadril_esquerdo': 'bebfbeeeag',
                    'nivel_mob_omb_direito': 'ihcdedbch',
                    'nivel_mob_omb_esquerdo': 'cabdhhajc',
                    'nivelPranchaVentral': 'hiijibcjd',
                    'nivelExtensaoColuna': 'dddeeaigg',
                    'nivelPranchaLateralDireita': 'bbbcfbgjj',
                    'nivelPranchaLateralEsquerda': 'bfebigbiai',
                    'pontosPranchaVentral': 488159273.114668,
                    'pontosExtensaoColuna': 1035618639.128774,
                    'pontosPranchaLateralDireita': 2002496997.169679,
                    'pontosPranchaLateralEsquerda': 66857835.119716,
                    'forcaRelativaAgachamento': 941507425.153409,
                    'forcaRelativaSupino': 842011463.195048,
                    'forcaRelativaTerra': 1444590749.152390,
                    'forcaRelativaBarraFixa': 2060492003.142935,
                    'squat_nivel': 'cbdicecefh',
                    'supino_nivel': 'bcfbaacegc',
                    'terra_nivel': 'igcddbjgh',
                    'pontuacao_squat_nivel': 155373836.14135,
                    'pontuacao_supino_nivel': 865930346.147028,
                    'pontuacao_terra_nivel': 668070392.16657,
                    'media_squat_jump': 58164534.57451,
                    'vo2_estimado': 1580217764.180715,
                    'faixa_etaria': 'hjjjibcfa',
                    'nivel_vo2': 'begjccaafb',
                    'IMC': 1007486992.144923,
                    'ClassificacaoIMC': 'badghjceg',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.FormularioAvaliacaoFisicaUpdateManyMutationInput,
        where: types.FormularioAvaliacaoFisicaWhereInput,
    ) -> int:
        """Update multiple FormularioAvaliacaoFisica records

        Parameters
        ----------
        data
            FormularioAvaliacaoFisica data to update the selected FormularioAvaliacaoFisica records to
        where
            Filter to select the FormularioAvaliacaoFisica records to update

        Returns
        -------
        int
            The total number of FormularioAvaliacaoFisica records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FormularioAvaliacaoFisica records
        total = FormularioAvaliacaoFisica.prisma().update_many(
            data={
                'modalidadeTreino': 'bcfcbbghhg'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.FormularioAvaliacaoFisicaWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FormularioAvaliacaoFisica records present in the database

        Parameters
        ----------
        select
            Select the FormularioAvaliacaoFisica fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FormularioAvaliacaoFisica filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FormularioAvaliacaoFisicaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = FormularioAvaliacaoFisica.prisma().count()

        # results: prisma.types.FormularioAvaliacaoFisicaCountAggregateOutput
        results = FormularioAvaliacaoFisica.prisma().count(
            select={
                '_all': True,
                'diaTreinoExtra': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.FormularioAvaliacaoFisicaCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.FormularioAvaliacaoFisicaWhereUniqueInput] = None,
    ) -> types.FormularioAvaliacaoFisicaCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.FormularioAvaliacaoFisicaCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None,
        cursor: Optional[types.FormularioAvaliacaoFisicaWhereUniqueInput] = None,
    ) -> Union[int, types.FormularioAvaliacaoFisicaCountAggregateOutput]:
        """Count the number of FormularioAvaliacaoFisica records present in the database

        Parameters
        ----------
        select
            Select the FormularioAvaliacaoFisica fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FormularioAvaliacaoFisica filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FormularioAvaliacaoFisicaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = FormularioAvaliacaoFisica.prisma().count()

        # results: prisma.types.FormularioAvaliacaoFisicaCountAggregateOutput
        results = FormularioAvaliacaoFisica.prisma().count(
            select={
                '_all': True,
                'modalidadeTreinoExtra': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FormularioAvaliacaoFisicaCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.FormularioAvaliacaoFisicaWhereInput] = None
    ) -> int:
        """Delete multiple FormularioAvaliacaoFisica records.

        Parameters
        ----------
        where
            Optional FormularioAvaliacaoFisica filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FormularioAvaliacaoFisica records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FormularioAvaliacaoFisica records
        total = FormularioAvaliacaoFisica.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.FormularioAvaliacaoFisicaScalarFieldKeys'],
        *,
        where: Optional['types.FormularioAvaliacaoFisicaWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FormularioAvaliacaoFisicaAvgAggregateInput'] = None,
        sum: Optional['types.FormularioAvaliacaoFisicaSumAggregateInput'] = None,
        min: Optional['types.FormularioAvaliacaoFisicaMinAggregateInput'] = None,
        max: Optional['types.FormularioAvaliacaoFisicaMaxAggregateInput'] = None,
        having: Optional['types.FormularioAvaliacaoFisicaScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FormularioAvaliacaoFisicaCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FormularioAvaliacaoFisicaScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FormularioAvaliacaoFisicaScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FormularioAvaliacaoFisicaGroupByOutput']:
        """Group FormularioAvaliacaoFisica records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FormularioAvaliacaoFisica fields to group records by
        where
            FormularioAvaliacaoFisica filter to select records
        take
            Limit the maximum number of FormularioAvaliacaoFisica records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FormularioAvaliacaoFisicaGroupByOutput]
            A list of dictionaries representing the FormularioAvaliacaoFisica record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FormularioAvaliacaoFisica records by altura values
        # and count how many records are in each group
        results = FormularioAvaliacaoFisica.prisma().group_by(
            ['altura'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TreinoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Treino]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Treino.prisma().query_raw(
            'SELECT * FROM Treino WHERE id = $1',
            'bdchdaccaj',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Treino
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Treino.prisma().query_first(
            'SELECT * FROM Treino WHERE nome = $1',
            'bfigahjhbi',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TreinoCreateInput,
        include: Optional[types.TreinoInclude] = None
    ) -> _PrismaModelT:
        """Create a new Treino record.

        Parameters
        ----------
        data
            Treino record data
        include
            Specifies which relations should be loaded on the returned Treino model

        Returns
        -------
        prisma.models.Treino
            The created Treino record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Treino record from just the required fields
        treino = Treino.prisma().create(
            data={
                # data to create a Treino record
                'nome': 'bjeaedjddf',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.TreinoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Treino records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Treino record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Treino.prisma().create_many(
            data=[
                {
                    # data to create a Treino record
                    'nome': 'bjgahcgeie',
                },
                {
                    # data to create a Treino record
                    'nome': 'ciedefhcf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TreinoWhereUniqueInput,
        include: Optional[types.TreinoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Treino record.

        Parameters
        ----------
        where
            Treino filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Treino model

        Returns
        -------
        prisma.models.Treino
            The deleted Treino record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        treino = Treino.prisma().delete(
            where={
                'id': 'hcfbbdjha',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.TreinoWhereUniqueInput,
        include: Optional[types.TreinoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Treino record.

        Parameters
        ----------
        where
            Treino filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Treino model

        Returns
        -------
        prisma.models.Treino
            The found Treino record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        treino = Treino.prisma().find_unique(
            where={
                'id': 'ijfeaiad',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.TreinoWhereUniqueInput,
        include: Optional[types.TreinoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Treino record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Treino filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Treino model

        Returns
        -------
        prisma.models.Treino
            The found Treino record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        treino = Treino.prisma().find_unique_or_raise(
            where={
                'id': 'bfafeaabci',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TreinoWhereInput] = None,
        cursor: Optional[types.TreinoWhereUniqueInput] = None,
        include: Optional[types.TreinoInclude] = None,
        order: Optional[Union[types.TreinoOrderByInput, List[types.TreinoOrderByInput]]] = None,
        distinct: Optional[List[types.TreinoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Treino records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Treino records returned
        skip
            Ignore the first N results
        where
            Treino filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Treino model
        order
            Order the returned Treino records by any field
        distinct
            Filter Treino records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Treino]
            The list of all Treino records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Treino records
        treinos = Treino.prisma().find_many(take=10)

        # find the first 5 Treino records ordered by the id field
        treinos = Treino.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TreinoWhereInput] = None,
        cursor: Optional[types.TreinoWhereUniqueInput] = None,
        include: Optional[types.TreinoInclude] = None,
        order: Optional[Union[types.TreinoOrderByInput, List[types.TreinoOrderByInput]]] = None,
        distinct: Optional[List[types.TreinoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Treino record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Treino filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Treino model
        order
            Order the returned Treino records by any field
        distinct
            Filter Treino records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Treino
            The first Treino record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Treino record ordered by the nome field
        treino = Treino.prisma().find_first(
            skip=1,
            order={
                'nome': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TreinoWhereInput] = None,
        cursor: Optional[types.TreinoWhereUniqueInput] = None,
        include: Optional[types.TreinoInclude] = None,
        order: Optional[Union[types.TreinoOrderByInput, List[types.TreinoOrderByInput]]] = None,
        distinct: Optional[List[types.TreinoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Treino record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Treino filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Treino model
        order
            Order the returned Treino records by any field
        distinct
            Filter Treino records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Treino
            The first Treino record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Treino record ordered by the id field
        treino = Treino.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.TreinoUpdateInput,
        where: types.TreinoWhereUniqueInput,
        include: Optional[types.TreinoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Treino record.

        Parameters
        ----------
        data
            Treino record data specifying what to update
        where
            Treino filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Treino model

        Returns
        -------
        prisma.models.Treino
            The updated Treino record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        treino = Treino.prisma().update(
            where={
                'id': 'badaediaaj',
            },
            data={
                # data to update the Treino record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.TreinoWhereUniqueInput,
        data: types.TreinoUpsertInput,
        include: Optional[types.TreinoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Treino filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Treino model

        Returns
        -------
        prisma.models.Treino
            The created or updated Treino record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        treino = Treino.prisma().upsert(
            where={
                'id': 'bdhacbdicc',
            },
            data={
                'create': {
                    'id': 'bdhacbdicc',
                    'nome': 'ciedefhcf',
                },
                'update': {
                    'nome': 'ciedefhcf',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.TreinoUpdateManyMutationInput,
        where: types.TreinoWhereInput,
    ) -> int:
        """Update multiple Treino records

        Parameters
        ----------
        data
            Treino data to update the selected Treino records to
        where
            Filter to select the Treino records to update

        Returns
        -------
        int
            The total number of Treino records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Treino records
        total = Treino.prisma().update_many(
            data={
                'nome': 'cbbaedeieh'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TreinoWhereInput] = None,
        cursor: Optional[types.TreinoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Treino records present in the database

        Parameters
        ----------
        select
            Select the Treino fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Treino filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TreinoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Treino.prisma().count()

        # results: prisma.types.TreinoCountAggregateOutput
        results = Treino.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TreinoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TreinoWhereInput] = None,
        cursor: Optional[types.TreinoWhereUniqueInput] = None,
    ) -> types.TreinoCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TreinoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TreinoWhereInput] = None,
        cursor: Optional[types.TreinoWhereUniqueInput] = None,
    ) -> Union[int, types.TreinoCountAggregateOutput]:
        """Count the number of Treino records present in the database

        Parameters
        ----------
        select
            Select the Treino fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Treino filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TreinoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Treino.prisma().count()

        # results: prisma.types.TreinoCountAggregateOutput
        results = Treino.prisma().count(
            select={
                '_all': True,
                'nome': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TreinoCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TreinoWhereInput] = None
    ) -> int:
        """Delete multiple Treino records.

        Parameters
        ----------
        where
            Optional Treino filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Treino records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Treino records
        total = Treino.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TreinoScalarFieldKeys'],
        *,
        where: Optional['types.TreinoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TreinoAvgAggregateInput'] = None,
        sum: Optional['types.TreinoSumAggregateInput'] = None,
        min: Optional['types.TreinoMinAggregateInput'] = None,
        max: Optional['types.TreinoMaxAggregateInput'] = None,
        having: Optional['types.TreinoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TreinoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TreinoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TreinoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TreinoGroupByOutput']:
        """Group Treino records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Treino fields to group records by
        where
            Treino filter to select records
        take
            Limit the maximum number of Treino records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TreinoGroupByOutput]
            A list of dictionaries representing the Treino record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Treino records by id values
        # and count how many records are in each group
        results = Treino.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RegistraTreinoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RegistraTreino]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = RegistraTreino.prisma().query_raw(
            'SELECT * FROM RegistraTreino WHERE id = $1',
            'bfdccbggie',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RegistraTreino
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = RegistraTreino.prisma().query_first(
            'SELECT * FROM RegistraTreino WHERE cdTipodeTreino = $1',
            'bagfhbfhd',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.RegistraTreinoCreateInput,
        include: Optional[types.RegistraTreinoInclude] = None
    ) -> _PrismaModelT:
        """Create a new RegistraTreino record.

        Parameters
        ----------
        data
            RegistraTreino record data
        include
            Specifies which relations should be loaded on the returned RegistraTreino model

        Returns
        -------
        prisma.models.RegistraTreino
            The created RegistraTreino record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RegistraTreino record from just the required fields
        registratreino = RegistraTreino.prisma().create(
            data={
                # data to create a RegistraTreino record
                'cdTipodeTreino': 'bjfbfjifdi',
                'cdTreino': 'gaddchiad',
                'userId': 'cbcbbcejfc',
                'dataHoraRegistroInterno': 'hfgccaddh',
                'dataHoraRegistroPeloUser': 'jjidgeicc',
                'treinoId': 'bjeaiaaacd',
                'escalacomosesente': 1310676484,
                'escaladisposicaoantesdasecao': 1520764909,
                'estadocontroleinterno': 788317730,
                'logdoprocessoderegistro': 'bhbgbifcgh',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.RegistraTreinoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RegistraTreino records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RegistraTreino record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = RegistraTreino.prisma().create_many(
            data=[
                {
                    # data to create a RegistraTreino record
                    'cdTipodeTreino': 'bdbcghddjc',
                    'cdTreino': 'bahbagigej',
                    'userId': 'ehecjcieg',
                    'dataHoraRegistroInterno': 'gihjffcbf',
                    'dataHoraRegistroPeloUser': 'giaajcaga',
                    'treinoId': 'jfeeiegef',
                    'escalacomosesente': 363132794,
                    'escaladisposicaoantesdasecao': 1560329003,
                    'estadocontroleinterno': 10025864,
                    'logdoprocessoderegistro': 'bijfcbheeb',
                },
                {
                    # data to create a RegistraTreino record
                    'cdTipodeTreino': 'beecfbhdbi',
                    'cdTreino': 'bacifbdfed',
                    'userId': 'eefaahjce',
                    'dataHoraRegistroInterno': 'bajhbcdecb',
                    'dataHoraRegistroPeloUser': 'dfgjhdfcc',
                    'treinoId': 'bbiagfgiad',
                    'escalacomosesente': 1079620512,
                    'escaladisposicaoantesdasecao': 1219259225,
                    'estadocontroleinterno': 435487518,
                    'logdoprocessoderegistro': 'jjhicigah',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.RegistraTreinoWhereUniqueInput,
        include: Optional[types.RegistraTreinoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RegistraTreino record.

        Parameters
        ----------
        where
            RegistraTreino filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RegistraTreino model

        Returns
        -------
        prisma.models.RegistraTreino
            The deleted RegistraTreino record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        registratreino = RegistraTreino.prisma().delete(
            where={
                'id': 'daffffjbg',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.RegistraTreinoWhereUniqueInput,
        include: Optional[types.RegistraTreinoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RegistraTreino record.

        Parameters
        ----------
        where
            RegistraTreino filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RegistraTreino model

        Returns
        -------
        prisma.models.RegistraTreino
            The found RegistraTreino record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        registratreino = RegistraTreino.prisma().find_unique(
            where={
                'id': 'bjggaeaaif',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.RegistraTreinoWhereUniqueInput,
        include: Optional[types.RegistraTreinoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RegistraTreino record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RegistraTreino filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RegistraTreino model

        Returns
        -------
        prisma.models.RegistraTreino
            The found RegistraTreino record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        registratreino = RegistraTreino.prisma().find_unique_or_raise(
            where={
                'id': 'dbhddieba',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RegistraTreinoWhereInput] = None,
        cursor: Optional[types.RegistraTreinoWhereUniqueInput] = None,
        include: Optional[types.RegistraTreinoInclude] = None,
        order: Optional[Union[types.RegistraTreinoOrderByInput, List[types.RegistraTreinoOrderByInput]]] = None,
        distinct: Optional[List[types.RegistraTreinoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RegistraTreino records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RegistraTreino records returned
        skip
            Ignore the first N results
        where
            RegistraTreino filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RegistraTreino model
        order
            Order the returned RegistraTreino records by any field
        distinct
            Filter RegistraTreino records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RegistraTreino]
            The list of all RegistraTreino records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RegistraTreino records
        registratreinos = RegistraTreino.prisma().find_many(take=10)

        # find the first 5 RegistraTreino records ordered by the cdTreino field
        registratreinos = RegistraTreino.prisma().find_many(
            take=5,
            order={
                'cdTreino': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RegistraTreinoWhereInput] = None,
        cursor: Optional[types.RegistraTreinoWhereUniqueInput] = None,
        include: Optional[types.RegistraTreinoInclude] = None,
        order: Optional[Union[types.RegistraTreinoOrderByInput, List[types.RegistraTreinoOrderByInput]]] = None,
        distinct: Optional[List[types.RegistraTreinoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RegistraTreino record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RegistraTreino filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RegistraTreino model
        order
            Order the returned RegistraTreino records by any field
        distinct
            Filter RegistraTreino records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RegistraTreino
            The first RegistraTreino record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RegistraTreino record ordered by the userId field
        registratreino = RegistraTreino.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RegistraTreinoWhereInput] = None,
        cursor: Optional[types.RegistraTreinoWhereUniqueInput] = None,
        include: Optional[types.RegistraTreinoInclude] = None,
        order: Optional[Union[types.RegistraTreinoOrderByInput, List[types.RegistraTreinoOrderByInput]]] = None,
        distinct: Optional[List[types.RegistraTreinoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RegistraTreino record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RegistraTreino filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RegistraTreino model
        order
            Order the returned RegistraTreino records by any field
        distinct
            Filter RegistraTreino records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RegistraTreino
            The first RegistraTreino record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RegistraTreino record ordered by the dataHoraRegistroInterno field
        registratreino = RegistraTreino.prisma().find_first_or_raise(
            skip=1,
            order={
                'dataHoraRegistroInterno': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.RegistraTreinoUpdateInput,
        where: types.RegistraTreinoWhereUniqueInput,
        include: Optional[types.RegistraTreinoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RegistraTreino record.

        Parameters
        ----------
        data
            RegistraTreino record data specifying what to update
        where
            RegistraTreino filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RegistraTreino model

        Returns
        -------
        prisma.models.RegistraTreino
            The updated RegistraTreino record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        registratreino = RegistraTreino.prisma().update(
            where={
                'id': 'gdeaefhcd',
            },
            data={
                # data to update the RegistraTreino record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.RegistraTreinoWhereUniqueInput,
        data: types.RegistraTreinoUpsertInput,
        include: Optional[types.RegistraTreinoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RegistraTreino filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RegistraTreino model

        Returns
        -------
        prisma.models.RegistraTreino
            The created or updated RegistraTreino record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        registratreino = RegistraTreino.prisma().upsert(
            where={
                'id': 'hfjfieeea',
            },
            data={
                'create': {
                    'id': 'hfjfieeea',
                    'cdTipodeTreino': 'beecfbhdbi',
                    'cdTreino': 'bacifbdfed',
                    'userId': 'eefaahjce',
                    'dataHoraRegistroInterno': 'bajhbcdecb',
                    'dataHoraRegistroPeloUser': 'dfgjhdfcc',
                    'treinoId': 'bbiagfgiad',
                    'escalacomosesente': 1079620512,
                    'escaladisposicaoantesdasecao': 1219259225,
                    'estadocontroleinterno': 435487518,
                    'logdoprocessoderegistro': 'jjhicigah',
                },
                'update': {
                    'cdTipodeTreino': 'beecfbhdbi',
                    'cdTreino': 'bacifbdfed',
                    'userId': 'eefaahjce',
                    'dataHoraRegistroInterno': 'bajhbcdecb',
                    'dataHoraRegistroPeloUser': 'dfgjhdfcc',
                    'treinoId': 'bbiagfgiad',
                    'escalacomosesente': 1079620512,
                    'escaladisposicaoantesdasecao': 1219259225,
                    'estadocontroleinterno': 435487518,
                    'logdoprocessoderegistro': 'jjhicigah',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.RegistraTreinoUpdateManyMutationInput,
        where: types.RegistraTreinoWhereInput,
    ) -> int:
        """Update multiple RegistraTreino records

        Parameters
        ----------
        data
            RegistraTreino data to update the selected RegistraTreino records to
        where
            Filter to select the RegistraTreino records to update

        Returns
        -------
        int
            The total number of RegistraTreino records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RegistraTreino records
        total = RegistraTreino.prisma().update_many(
            data={
                'dataHoraRegistroPeloUser': 'cbecbiggeb'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RegistraTreinoWhereInput] = None,
        cursor: Optional[types.RegistraTreinoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RegistraTreino records present in the database

        Parameters
        ----------
        select
            Select the RegistraTreino fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RegistraTreino filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RegistraTreinoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = RegistraTreino.prisma().count()

        # results: prisma.types.RegistraTreinoCountAggregateOutput
        results = RegistraTreino.prisma().count(
            select={
                '_all': True,
                'treinoId': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.RegistraTreinoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RegistraTreinoWhereInput] = None,
        cursor: Optional[types.RegistraTreinoWhereUniqueInput] = None,
    ) -> types.RegistraTreinoCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.RegistraTreinoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RegistraTreinoWhereInput] = None,
        cursor: Optional[types.RegistraTreinoWhereUniqueInput] = None,
    ) -> Union[int, types.RegistraTreinoCountAggregateOutput]:
        """Count the number of RegistraTreino records present in the database

        Parameters
        ----------
        select
            Select the RegistraTreino fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RegistraTreino filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RegistraTreinoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = RegistraTreino.prisma().count()

        # results: prisma.types.RegistraTreinoCountAggregateOutput
        results = RegistraTreino.prisma().count(
            select={
                '_all': True,
                'escalacomosesente': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RegistraTreinoCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.RegistraTreinoWhereInput] = None
    ) -> int:
        """Delete multiple RegistraTreino records.

        Parameters
        ----------
        where
            Optional RegistraTreino filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RegistraTreino records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RegistraTreino records
        total = RegistraTreino.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.RegistraTreinoScalarFieldKeys'],
        *,
        where: Optional['types.RegistraTreinoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RegistraTreinoAvgAggregateInput'] = None,
        sum: Optional['types.RegistraTreinoSumAggregateInput'] = None,
        min: Optional['types.RegistraTreinoMinAggregateInput'] = None,
        max: Optional['types.RegistraTreinoMaxAggregateInput'] = None,
        having: Optional['types.RegistraTreinoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RegistraTreinoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RegistraTreinoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RegistraTreinoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RegistraTreinoGroupByOutput']:
        """Group RegistraTreino records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RegistraTreino fields to group records by
        where
            RegistraTreino filter to select records
        take
            Limit the maximum number of RegistraTreino records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RegistraTreinoGroupByOutput]
            A list of dictionaries representing the RegistraTreino record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RegistraTreino records by escaladisposicaoantesdasecao values
        # and count how many records are in each group
        results = RegistraTreino.prisma().group_by(
            ['escaladisposicaoantesdasecao'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models