# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    name: Optional[_str] = None
    email: Optional[_str] = None
    emailVerified: Optional[datetime.datetime] = None
    image: Optional[_str] = None
    stripeCustomerId: Optional[_str] = None
    stripeSubscriptionId: Optional[_str] = None
    stripeSubscriptionStatus: Optional[_str] = None
    stripePriceId: Optional[_str] = None
    accounts: Optional[List['models.Account']] = None
    sessions: Optional[List['models.Session']] = None
    todos: Optional[List['models.Todo']] = None
    userType: Optional[List['models.UserType']] = None
    profiles: Optional[List['models.Profile']] = None
    gyms: Optional[List['models.Gym']] = None
    responsibleGyms: Optional[List['models.Gym']] = None
    isResponsibleForBilling: _bool
    questionarioProntidaoAvaliacaoFisica: Optional[List['models.QuestionarioProntidaoAvaliacaoFisica']] = None
    formularioAvaliacaoFisica: Optional[List['models.FormularioAvaliacaoFisica']] = None
    registros: Optional[List['models.RegistraTreino']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Profile(bases.BaseProfile):
    """Represents a Profile record"""

    id: _str
    role: Optional['models.Role'] = None
    roleId: _str
    user: Optional['models.User'] = None
    userId: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProfileKeys']] = None,
        exclude: Optional[Iterable['types.ProfileKeys']] = None,
        required: Optional[Iterable['types.ProfileKeys']] = None,
        optional: Optional[Iterable['types.ProfileKeys']] = None,
        relations: Optional[Mapping['types.ProfileRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProfileKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Profile_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Profile_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Profile_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Profile_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Profile_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Profile_relational_fields:
                        raise errors.UnknownRelationalFieldError('Profile', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Profile / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Profile',
            }
        )
        _created_partial_types.add(name)


class Role(bases.BaseRole):
    """Represents a Role record"""

    id: _str
    name: _str
    profiles: Optional[List['models.Profile']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RoleKeys']] = None,
        exclude: Optional[Iterable['types.RoleKeys']] = None,
        required: Optional[Iterable['types.RoleKeys']] = None,
        optional: Optional[Iterable['types.RoleKeys']] = None,
        relations: Optional[Mapping['types.RoleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RoleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Role_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Role_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Role_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Role_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Role_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Role_relational_fields:
                        raise errors.UnknownRelationalFieldError('Role', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Role / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Role',
            }
        )
        _created_partial_types.add(name)


class Gym(bases.BaseGym):
    """Represents a Gym record"""

    id: _str
    name: _str
    location: _str
    users: Optional[List['models.User']] = None
    responsibleId: Optional[_str] = None
    responsible: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GymKeys']] = None,
        exclude: Optional[Iterable['types.GymKeys']] = None,
        required: Optional[Iterable['types.GymKeys']] = None,
        optional: Optional[Iterable['types.GymKeys']] = None,
        relations: Optional[Mapping['types.GymRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GymKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Gym_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Gym_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Gym_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Gym_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Gym_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Gym_relational_fields:
                        raise errors.UnknownRelationalFieldError('Gym', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Gym / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Gym',
            }
        )
        _created_partial_types.add(name)


class UserType(bases.BaseUserType):
    """Represents a UserType record"""

    id: _str
    perfil: _str
    user: Optional['models.User'] = None
    userId: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserTypeKeys']] = None,
        exclude: Optional[Iterable['types.UserTypeKeys']] = None,
        required: Optional[Iterable['types.UserTypeKeys']] = None,
        optional: Optional[Iterable['types.UserTypeKeys']] = None,
        relations: Optional[Mapping['types.UserTypeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserTypeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserType_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserType_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserType_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserType_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserType_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserType_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserType', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserType / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserType',
            }
        )
        _created_partial_types.add(name)


class Account(bases.BaseAccount):
    """Represents a Account record"""

    id: _str
    userId: _str
    type: _str
    provider: _str
    providerAccountId: _str
    refresh_token: Optional[_str] = None
    access_token: Optional[_str] = None
    expires_at: Optional[_int] = None
    token_type: Optional[_str] = None
    scope: Optional[_str] = None
    id_token: Optional[_str] = None
    session_state: Optional[_str] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AccountKeys']] = None,
        exclude: Optional[Iterable['types.AccountKeys']] = None,
        required: Optional[Iterable['types.AccountKeys']] = None,
        optional: Optional[Iterable['types.AccountKeys']] = None,
        relations: Optional[Mapping['types.AccountRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AccountKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Account_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Account_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Account_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Account_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Account_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Account_relational_fields:
                        raise errors.UnknownRelationalFieldError('Account', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Account / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Account',
            }
        )
        _created_partial_types.add(name)


class Session(bases.BaseSession):
    """Represents a Session record"""

    id: _str
    sessionToken: _str
    userId: _str
    expires: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SessionKeys']] = None,
        exclude: Optional[Iterable['types.SessionKeys']] = None,
        required: Optional[Iterable['types.SessionKeys']] = None,
        optional: Optional[Iterable['types.SessionKeys']] = None,
        relations: Optional[Mapping['types.SessionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SessionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Session_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Session_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Session_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Session_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Session_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Session_relational_fields:
                        raise errors.UnknownRelationalFieldError('Session', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Session / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Session',
            }
        )
        _created_partial_types.add(name)


class VerificationToken(bases.BaseVerificationToken):
    """Represents a VerificationToken record"""

    identifier: _str
    token: _str
    expires: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.VerificationTokenKeys']] = None,
        exclude: Optional[Iterable['types.VerificationTokenKeys']] = None,
        required: Optional[Iterable['types.VerificationTokenKeys']] = None,
        optional: Optional[Iterable['types.VerificationTokenKeys']] = None,
        relations: Optional[Mapping['types.VerificationTokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.VerificationTokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _VerificationToken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _VerificationToken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _VerificationToken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _VerificationToken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "VerificationToken" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid VerificationToken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'VerificationToken',
            }
        )
        _created_partial_types.add(name)


class Todo(bases.BaseTodo):
    """Represents a Todo record"""

    id: _str
    title: _str
    userId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None
    doneAt: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TodoKeys']] = None,
        exclude: Optional[Iterable['types.TodoKeys']] = None,
        required: Optional[Iterable['types.TodoKeys']] = None,
        optional: Optional[Iterable['types.TodoKeys']] = None,
        relations: Optional[Mapping['types.TodoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TodoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Todo_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Todo_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Todo_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Todo_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Todo_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Todo_relational_fields:
                        raise errors.UnknownRelationalFieldError('Todo', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Todo / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Todo',
            }
        )
        _created_partial_types.add(name)


class QuestionarioProntidaoAvaliacaoFisica(bases.BaseQuestionarioProntidaoAvaliacaoFisica):
    """Represents a QuestionarioProntidaoAvaliacaoFisica record"""

    id: _str
    aluno: _str
    userId: _str
    user: Optional['models.User'] = None
    sexo: _str
    treinador: _str
    dataNascimento: _str
    Objetivo: _str
    tempoTreinamentoIninterruptoAtual: _str
    tempoDestreinamento: _str
    experienciaPreviaTreinamento: _str
    frequenciaMusculacao: _str
    modalidadeExtra: _str
    frequenciaModalidadeExtra: _str
    altura: _float
    peso: _float
    torax: _float
    cintura: _float
    abdomen: _float
    quadril: _float
    braco_d: _float
    braco_e: _float
    coxa_d: _float
    coxa_e: _float
    panturrilha_d: _float
    panturrilha_e: _float
    medidaMao: _float
    mobilidadeGlenoumeralDireita: _float
    mobilidadeGlenoumeralEsquerda: _float
    AmplitudeMovimentoQuadrilDireito: _float
    AmplitudeMovimentoQuadrilEsquerdo: _float
    AmplitudeMovimentoTornozeloDireito: _float
    AmplitudeMovimentoTornozeloEsquerdo: _float
    pranchaVentral: _float
    extensaoColuna: _float
    pranchaLateralDireita: _float
    pranchaLateralEsquerda: _float
    squatJump1: _float
    squatJump2: _float
    squatJump3: _float
    RMagachamento: _float
    RMsupino: _float
    RMterra: _float
    RMbarraFixa: _float
    VelocidadeAerobiaMaxima: _float
    bracoDireito: _float
    bracoEsquerdo: _float
    coxaDireita: _float
    coxaEsquerda: _float
    panturrilhaDireita: _float
    panturrilhaEsquerda: _float
    idade: _int
    data: _str
    hora: _str
    pontuacaoTempoTreinoAtual: _int
    pontuacao_tempo_de_destreinamento_atual: _int
    pontuacao_experiencia_previa_de_treinamento: _int
    pontuacao_media_nivel_treinamento: _float
    status_de_treinamento: _str
    nivel_mob_torn_direito: _str
    nivel_mob_torn_esquerdo: _str
    nivel_mob_quadril_direito: _str
    nivel_mob_quadril_esquerdo: _str
    nivel_mob_omb_direito: _str
    nivel_mob_omb_esquerdo: _str
    nivelPranchaVentral: _str
    nivelExtensaoColuna: _str
    nivelPranchaLateralDireita: _str
    nivelPranchaLateralEsquerda: _str
    pontosPranchaVentral: _float
    pontosExtensaoColuna: _float
    pontosPranchaLateralDireita: _float
    pontosPranchaLateralEsquerda: _float
    forcaRelativaAgachamento: _float
    forcaRelativaSupino: _float
    forcaRelativaTerra: _float
    forcaRelativaBarraFixa: _float
    squat_nivel: _str
    supino_nivel: _str
    terra_nivel: _str
    pontuacao_squat_nivel: _float
    pontuacao_supino_nivel: _float
    pontuacao_terra_nivel: _float
    media_squat_jump: _float
    vo2_estimado: _float
    faixa_etaria: _str
    nivel_vo2: _str
    IMC: _float
    ClassificacaoIMC: _str
    idtagaluno: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.QuestionarioProntidaoAvaliacaoFisicaKeys']] = None,
        exclude: Optional[Iterable['types.QuestionarioProntidaoAvaliacaoFisicaKeys']] = None,
        required: Optional[Iterable['types.QuestionarioProntidaoAvaliacaoFisicaKeys']] = None,
        optional: Optional[Iterable['types.QuestionarioProntidaoAvaliacaoFisicaKeys']] = None,
        relations: Optional[Mapping['types.QuestionarioProntidaoAvaliacaoFisicaRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.QuestionarioProntidaoAvaliacaoFisicaKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _QuestionarioProntidaoAvaliacaoFisica_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _QuestionarioProntidaoAvaliacaoFisica_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _QuestionarioProntidaoAvaliacaoFisica_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _QuestionarioProntidaoAvaliacaoFisica_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _QuestionarioProntidaoAvaliacaoFisica_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _QuestionarioProntidaoAvaliacaoFisica_relational_fields:
                        raise errors.UnknownRelationalFieldError('QuestionarioProntidaoAvaliacaoFisica', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid QuestionarioProntidaoAvaliacaoFisica / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'QuestionarioProntidaoAvaliacaoFisica',
            }
        )
        _created_partial_types.add(name)


class FormularioAvaliacaoFisica(bases.BaseFormularioAvaliacaoFisica):
    """Represents a FormularioAvaliacaoFisica record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    aluno: _str
    treinador: _str
    diaTreino: _str
    modalidadeTreino: _str
    diaTreinoExtra: _str
    modalidadeTreinoExtra: _str
    altura: _float
    peso: _float
    torax: _float
    cintura: _float
    abdomen: _float
    quadril: _float
    braco_d: _float
    braco_e: _float
    coxa_d: _float
    coxa_e: _float
    panturrilha_d: _float
    panturrilha_e: _float
    medidaMao: _float
    mobilidadeGlenoumeralDireita: _float
    mobilidadeGlenoumeralEsquerda: _float
    AmplitudeMovimentoQuadrilDireito: _float
    AmplitudeMovimentoQuadrilEsquerdo: _float
    AmplitudeMovimentoTornozeloDireito: _float
    AmplitudeMovimentoTornozeloEsquerdo: _float
    pranchaVentral: _float
    extensaoColuna: _float
    pranchaLateralDireita: _float
    pranchaLateralEsquerda: _float
    squatJump1: _float
    squatJump2: _float
    squatJump3: _float
    RMagachamento: _float
    RMsupino: _float
    RMterra: _float
    RMbarraFixa: _float
    VelocidadeAerobiaMaxima: _float
    bracoDireito: _float
    bracoEsquerdo: _float
    coxaDireita: _float
    coxaEsquerda: _float
    panturrilhaDireita: _float
    panturrilhaEsquerda: _float
    idade: _int
    data: _str
    hora: _str
    pontuacaoTempoTreinoAtual: _int
    pontuacao_tempo_de_destreinamento_atual: _int
    pontuacao_experiencia_previa_de_treinamento: _int
    pontuacao_media_nivel_treinamento: _float
    status_de_treinamento: _str
    nivel_mob_torn_direito: _str
    nivel_mob_torn_esquerdo: _str
    nivel_mob_quadril_direito: _str
    nivel_mob_quadril_esquerdo: _str
    nivel_mob_omb_direito: _str
    nivel_mob_omb_esquerdo: _str
    nivelPranchaVentral: _str
    nivelExtensaoColuna: _str
    nivelPranchaLateralDireita: _str
    nivelPranchaLateralEsquerda: _str
    pontosPranchaVentral: _float
    pontosExtensaoColuna: _float
    pontosPranchaLateralDireita: _float
    pontosPranchaLateralEsquerda: _float
    forcaRelativaAgachamento: _float
    forcaRelativaSupino: _float
    forcaRelativaTerra: _float
    forcaRelativaBarraFixa: _float
    squat_nivel: _str
    supino_nivel: _str
    terra_nivel: _str
    pontuacao_squat_nivel: _float
    pontuacao_supino_nivel: _float
    pontuacao_terra_nivel: _float
    media_squat_jump: _float
    vo2_estimado: _float
    faixa_etaria: _str
    nivel_vo2: _str
    IMC: _float
    ClassificacaoIMC: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FormularioAvaliacaoFisicaKeys']] = None,
        exclude: Optional[Iterable['types.FormularioAvaliacaoFisicaKeys']] = None,
        required: Optional[Iterable['types.FormularioAvaliacaoFisicaKeys']] = None,
        optional: Optional[Iterable['types.FormularioAvaliacaoFisicaKeys']] = None,
        relations: Optional[Mapping['types.FormularioAvaliacaoFisicaRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FormularioAvaliacaoFisicaKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _FormularioAvaliacaoFisica_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _FormularioAvaliacaoFisica_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _FormularioAvaliacaoFisica_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _FormularioAvaliacaoFisica_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _FormularioAvaliacaoFisica_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _FormularioAvaliacaoFisica_relational_fields:
                        raise errors.UnknownRelationalFieldError('FormularioAvaliacaoFisica', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid FormularioAvaliacaoFisica / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'FormularioAvaliacaoFisica',
            }
        )
        _created_partial_types.add(name)


class Treino(bases.BaseTreino):
    """Represents a Treino record"""

    id: _str
    nome: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TreinoKeys']] = None,
        exclude: Optional[Iterable['types.TreinoKeys']] = None,
        required: Optional[Iterable['types.TreinoKeys']] = None,
        optional: Optional[Iterable['types.TreinoKeys']] = None,
        relations: Optional[Mapping['types.TreinoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TreinoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Treino_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Treino_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Treino_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Treino_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Treino" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Treino / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Treino',
            }
        )
        _created_partial_types.add(name)


class RegistraTreino(bases.BaseRegistraTreino):
    """Represents a RegistraTreino record"""

    id: _str
    cdTipodeTreino: _str
    cdTreino: _str
    userId: _str
    user: Optional['models.User'] = None
    dataHoraRegistroInterno: _str
    dataHoraRegistroPeloUser: _str
    treinoId: _str
    escalacomosesente: _int
    escaladisposicaoantesdasecao: _int
    estadocontroleinterno: _int
    logdoprocessoderegistro: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RegistraTreinoKeys']] = None,
        exclude: Optional[Iterable['types.RegistraTreinoKeys']] = None,
        required: Optional[Iterable['types.RegistraTreinoKeys']] = None,
        optional: Optional[Iterable['types.RegistraTreinoKeys']] = None,
        relations: Optional[Mapping['types.RegistraTreinoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RegistraTreinoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RegistraTreino_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RegistraTreino_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RegistraTreino_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RegistraTreino_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RegistraTreino_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RegistraTreino_relational_fields:
                        raise errors.UnknownRelationalFieldError('RegistraTreino', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RegistraTreino / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RegistraTreino',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'accounts',
        'sessions',
        'todos',
        'userType',
        'profiles',
        'gyms',
        'responsibleGyms',
        'questionarioProntidaoAvaliacaoFisica',
        'formularioAvaliacaoFisica',
        'registros',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailVerified', {
            'name': 'emailVerified',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('image', {
            'name': 'image',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripeCustomerId', {
            'name': 'stripeCustomerId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripeSubscriptionId', {
            'name': 'stripeSubscriptionId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripeSubscriptionStatus', {
            'name': 'stripeSubscriptionStatus',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripePriceId', {
            'name': 'stripePriceId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accounts', {
            'name': 'accounts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Account\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sessions', {
            'name': 'sessions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Session\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('todos', {
            'name': 'todos',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Todo\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userType', {
            'name': 'userType',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserType\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('profiles', {
            'name': 'profiles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Profile\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('gyms', {
            'name': 'gyms',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Gym\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('responsibleGyms', {
            'name': 'responsibleGyms',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Gym\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('isResponsibleForBilling', {
            'name': 'isResponsibleForBilling',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('questionarioProntidaoAvaliacaoFisica', {
            'name': 'questionarioProntidaoAvaliacaoFisica',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.QuestionarioProntidaoAvaliacaoFisica\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('formularioAvaliacaoFisica', {
            'name': 'formularioAvaliacaoFisica',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.FormularioAvaliacaoFisica\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('registros', {
            'name': 'registros',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RegistraTreino\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Profile_relational_fields: Set[str] = {
        'role',
        'user',
    }
_Profile_fields: Dict['types.ProfileKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': True,
            'type': 'models.Role',
            'is_relational': True,
            'documentation': None,
        }),
        ('roleId', {
            'name': 'roleId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Role_relational_fields: Set[str] = {
        'profiles',
    }
_Role_fields: Dict['types.RoleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('profiles', {
            'name': 'profiles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Profile\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Gym_relational_fields: Set[str] = {
        'users',
        'responsible',
    }
_Gym_fields: Dict['types.GymKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.User\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('responsibleId', {
            'name': 'responsibleId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('responsible', {
            'name': 'responsible',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserType_relational_fields: Set[str] = {
        'user',
    }
_UserType_fields: Dict['types.UserTypeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('perfil', {
            'name': 'perfil',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Account_relational_fields: Set[str] = {
        'user',
    }
_Account_fields: Dict['types.AccountKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('provider', {
            'name': 'provider',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('providerAccountId', {
            'name': 'providerAccountId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('refresh_token', {
            'name': 'refresh_token',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('access_token', {
            'name': 'access_token',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires_at', {
            'name': 'expires_at',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('token_type', {
            'name': 'token_type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('scope', {
            'name': 'scope',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('id_token', {
            'name': 'id_token',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('session_state', {
            'name': 'session_state',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Session_relational_fields: Set[str] = {
        'user',
    }
_Session_fields: Dict['types.SessionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sessionToken', {
            'name': 'sessionToken',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires', {
            'name': 'expires',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_VerificationToken_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_VerificationToken_fields: Dict['types.VerificationTokenKeys', PartialModelField] = OrderedDict(
    [
        ('identifier', {
            'name': 'identifier',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires', {
            'name': 'expires',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Todo_relational_fields: Set[str] = {
        'user',
    }
_Todo_fields: Dict['types.TodoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('doneAt', {
            'name': 'doneAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_QuestionarioProntidaoAvaliacaoFisica_relational_fields: Set[str] = {
        'user',
    }
_QuestionarioProntidaoAvaliacaoFisica_fields: Dict['types.QuestionarioProntidaoAvaliacaoFisicaKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('aluno', {
            'name': 'aluno',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('sexo', {
            'name': 'sexo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('treinador', {
            'name': 'treinador',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dataNascimento', {
            'name': 'dataNascimento',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Objetivo', {
            'name': 'Objetivo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tempoTreinamentoIninterruptoAtual', {
            'name': 'tempoTreinamentoIninterruptoAtual',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tempoDestreinamento', {
            'name': 'tempoDestreinamento',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('experienciaPreviaTreinamento', {
            'name': 'experienciaPreviaTreinamento',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequenciaMusculacao', {
            'name': 'frequenciaMusculacao',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('modalidadeExtra', {
            'name': 'modalidadeExtra',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequenciaModalidadeExtra', {
            'name': 'frequenciaModalidadeExtra',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('altura', {
            'name': 'altura',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('peso', {
            'name': 'peso',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('torax', {
            'name': 'torax',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('cintura', {
            'name': 'cintura',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('abdomen', {
            'name': 'abdomen',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('quadril', {
            'name': 'quadril',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('braco_d', {
            'name': 'braco_d',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('braco_e', {
            'name': 'braco_e',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxa_d', {
            'name': 'coxa_d',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxa_e', {
            'name': 'coxa_e',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilha_d', {
            'name': 'panturrilha_d',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilha_e', {
            'name': 'panturrilha_e',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('medidaMao', {
            'name': 'medidaMao',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('mobilidadeGlenoumeralDireita', {
            'name': 'mobilidadeGlenoumeralDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('mobilidadeGlenoumeralEsquerda', {
            'name': 'mobilidadeGlenoumeralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoQuadrilDireito', {
            'name': 'AmplitudeMovimentoQuadrilDireito',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoQuadrilEsquerdo', {
            'name': 'AmplitudeMovimentoQuadrilEsquerdo',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoTornozeloDireito', {
            'name': 'AmplitudeMovimentoTornozeloDireito',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoTornozeloEsquerdo', {
            'name': 'AmplitudeMovimentoTornozeloEsquerdo',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pranchaVentral', {
            'name': 'pranchaVentral',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('extensaoColuna', {
            'name': 'extensaoColuna',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pranchaLateralDireita', {
            'name': 'pranchaLateralDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pranchaLateralEsquerda', {
            'name': 'pranchaLateralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squatJump1', {
            'name': 'squatJump1',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squatJump2', {
            'name': 'squatJump2',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squatJump3', {
            'name': 'squatJump3',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMagachamento', {
            'name': 'RMagachamento',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMsupino', {
            'name': 'RMsupino',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMterra', {
            'name': 'RMterra',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMbarraFixa', {
            'name': 'RMbarraFixa',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('VelocidadeAerobiaMaxima', {
            'name': 'VelocidadeAerobiaMaxima',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('bracoDireito', {
            'name': 'bracoDireito',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('bracoEsquerdo', {
            'name': 'bracoEsquerdo',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxaDireita', {
            'name': 'coxaDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxaEsquerda', {
            'name': 'coxaEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilhaDireita', {
            'name': 'panturrilhaDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilhaEsquerda', {
            'name': 'panturrilhaEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('idade', {
            'name': 'idade',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('data', {
            'name': 'data',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hora', {
            'name': 'hora',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacaoTempoTreinoAtual', {
            'name': 'pontuacaoTempoTreinoAtual',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_tempo_de_destreinamento_atual', {
            'name': 'pontuacao_tempo_de_destreinamento_atual',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_experiencia_previa_de_treinamento', {
            'name': 'pontuacao_experiencia_previa_de_treinamento',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_media_nivel_treinamento', {
            'name': 'pontuacao_media_nivel_treinamento',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('status_de_treinamento', {
            'name': 'status_de_treinamento',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_torn_direito', {
            'name': 'nivel_mob_torn_direito',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_torn_esquerdo', {
            'name': 'nivel_mob_torn_esquerdo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_quadril_direito', {
            'name': 'nivel_mob_quadril_direito',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_quadril_esquerdo', {
            'name': 'nivel_mob_quadril_esquerdo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_omb_direito', {
            'name': 'nivel_mob_omb_direito',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_omb_esquerdo', {
            'name': 'nivel_mob_omb_esquerdo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelPranchaVentral', {
            'name': 'nivelPranchaVentral',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelExtensaoColuna', {
            'name': 'nivelExtensaoColuna',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelPranchaLateralDireita', {
            'name': 'nivelPranchaLateralDireita',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelPranchaLateralEsquerda', {
            'name': 'nivelPranchaLateralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosPranchaVentral', {
            'name': 'pontosPranchaVentral',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosExtensaoColuna', {
            'name': 'pontosExtensaoColuna',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosPranchaLateralDireita', {
            'name': 'pontosPranchaLateralDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosPranchaLateralEsquerda', {
            'name': 'pontosPranchaLateralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaAgachamento', {
            'name': 'forcaRelativaAgachamento',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaSupino', {
            'name': 'forcaRelativaSupino',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaTerra', {
            'name': 'forcaRelativaTerra',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaBarraFixa', {
            'name': 'forcaRelativaBarraFixa',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squat_nivel', {
            'name': 'squat_nivel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('supino_nivel', {
            'name': 'supino_nivel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('terra_nivel', {
            'name': 'terra_nivel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_squat_nivel', {
            'name': 'pontuacao_squat_nivel',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_supino_nivel', {
            'name': 'pontuacao_supino_nivel',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_terra_nivel', {
            'name': 'pontuacao_terra_nivel',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('media_squat_jump', {
            'name': 'media_squat_jump',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('vo2_estimado', {
            'name': 'vo2_estimado',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('faixa_etaria', {
            'name': 'faixa_etaria',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_vo2', {
            'name': 'nivel_vo2',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('IMC', {
            'name': 'IMC',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('ClassificacaoIMC', {
            'name': 'ClassificacaoIMC',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('idtagaluno', {
            'name': 'idtagaluno',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_FormularioAvaliacaoFisica_relational_fields: Set[str] = {
        'user',
    }
_FormularioAvaliacaoFisica_fields: Dict['types.FormularioAvaliacaoFisicaKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('aluno', {
            'name': 'aluno',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('treinador', {
            'name': 'treinador',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('diaTreino', {
            'name': 'diaTreino',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('modalidadeTreino', {
            'name': 'modalidadeTreino',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('diaTreinoExtra', {
            'name': 'diaTreinoExtra',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('modalidadeTreinoExtra', {
            'name': 'modalidadeTreinoExtra',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('altura', {
            'name': 'altura',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('peso', {
            'name': 'peso',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('torax', {
            'name': 'torax',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('cintura', {
            'name': 'cintura',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('abdomen', {
            'name': 'abdomen',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('quadril', {
            'name': 'quadril',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('braco_d', {
            'name': 'braco_d',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('braco_e', {
            'name': 'braco_e',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxa_d', {
            'name': 'coxa_d',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxa_e', {
            'name': 'coxa_e',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilha_d', {
            'name': 'panturrilha_d',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilha_e', {
            'name': 'panturrilha_e',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('medidaMao', {
            'name': 'medidaMao',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('mobilidadeGlenoumeralDireita', {
            'name': 'mobilidadeGlenoumeralDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('mobilidadeGlenoumeralEsquerda', {
            'name': 'mobilidadeGlenoumeralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoQuadrilDireito', {
            'name': 'AmplitudeMovimentoQuadrilDireito',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoQuadrilEsquerdo', {
            'name': 'AmplitudeMovimentoQuadrilEsquerdo',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoTornozeloDireito', {
            'name': 'AmplitudeMovimentoTornozeloDireito',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('AmplitudeMovimentoTornozeloEsquerdo', {
            'name': 'AmplitudeMovimentoTornozeloEsquerdo',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pranchaVentral', {
            'name': 'pranchaVentral',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('extensaoColuna', {
            'name': 'extensaoColuna',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pranchaLateralDireita', {
            'name': 'pranchaLateralDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pranchaLateralEsquerda', {
            'name': 'pranchaLateralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squatJump1', {
            'name': 'squatJump1',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squatJump2', {
            'name': 'squatJump2',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squatJump3', {
            'name': 'squatJump3',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMagachamento', {
            'name': 'RMagachamento',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMsupino', {
            'name': 'RMsupino',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMterra', {
            'name': 'RMterra',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('RMbarraFixa', {
            'name': 'RMbarraFixa',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('VelocidadeAerobiaMaxima', {
            'name': 'VelocidadeAerobiaMaxima',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('bracoDireito', {
            'name': 'bracoDireito',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('bracoEsquerdo', {
            'name': 'bracoEsquerdo',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxaDireita', {
            'name': 'coxaDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('coxaEsquerda', {
            'name': 'coxaEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilhaDireita', {
            'name': 'panturrilhaDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('panturrilhaEsquerda', {
            'name': 'panturrilhaEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('idade', {
            'name': 'idade',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('data', {
            'name': 'data',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hora', {
            'name': 'hora',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacaoTempoTreinoAtual', {
            'name': 'pontuacaoTempoTreinoAtual',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_tempo_de_destreinamento_atual', {
            'name': 'pontuacao_tempo_de_destreinamento_atual',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_experiencia_previa_de_treinamento', {
            'name': 'pontuacao_experiencia_previa_de_treinamento',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_media_nivel_treinamento', {
            'name': 'pontuacao_media_nivel_treinamento',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('status_de_treinamento', {
            'name': 'status_de_treinamento',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_torn_direito', {
            'name': 'nivel_mob_torn_direito',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_torn_esquerdo', {
            'name': 'nivel_mob_torn_esquerdo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_quadril_direito', {
            'name': 'nivel_mob_quadril_direito',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_quadril_esquerdo', {
            'name': 'nivel_mob_quadril_esquerdo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_omb_direito', {
            'name': 'nivel_mob_omb_direito',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_mob_omb_esquerdo', {
            'name': 'nivel_mob_omb_esquerdo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelPranchaVentral', {
            'name': 'nivelPranchaVentral',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelExtensaoColuna', {
            'name': 'nivelExtensaoColuna',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelPranchaLateralDireita', {
            'name': 'nivelPranchaLateralDireita',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivelPranchaLateralEsquerda', {
            'name': 'nivelPranchaLateralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosPranchaVentral', {
            'name': 'pontosPranchaVentral',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosExtensaoColuna', {
            'name': 'pontosExtensaoColuna',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosPranchaLateralDireita', {
            'name': 'pontosPranchaLateralDireita',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontosPranchaLateralEsquerda', {
            'name': 'pontosPranchaLateralEsquerda',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaAgachamento', {
            'name': 'forcaRelativaAgachamento',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaSupino', {
            'name': 'forcaRelativaSupino',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaTerra', {
            'name': 'forcaRelativaTerra',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('forcaRelativaBarraFixa', {
            'name': 'forcaRelativaBarraFixa',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('squat_nivel', {
            'name': 'squat_nivel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('supino_nivel', {
            'name': 'supino_nivel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('terra_nivel', {
            'name': 'terra_nivel',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_squat_nivel', {
            'name': 'pontuacao_squat_nivel',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_supino_nivel', {
            'name': 'pontuacao_supino_nivel',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pontuacao_terra_nivel', {
            'name': 'pontuacao_terra_nivel',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('media_squat_jump', {
            'name': 'media_squat_jump',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('vo2_estimado', {
            'name': 'vo2_estimado',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('faixa_etaria', {
            'name': 'faixa_etaria',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nivel_vo2', {
            'name': 'nivel_vo2',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('IMC', {
            'name': 'IMC',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('ClassificacaoIMC', {
            'name': 'ClassificacaoIMC',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Treino_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Treino_fields: Dict['types.TreinoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nome', {
            'name': 'nome',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_RegistraTreino_relational_fields: Set[str] = {
        'user',
    }
_RegistraTreino_fields: Dict['types.RegistraTreinoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cdTipodeTreino', {
            'name': 'cdTipodeTreino',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cdTreino', {
            'name': 'cdTreino',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('dataHoraRegistroInterno', {
            'name': 'dataHoraRegistroInterno',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dataHoraRegistroPeloUser', {
            'name': 'dataHoraRegistroPeloUser',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('treinoId', {
            'name': 'treinoId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('escalacomosesente', {
            'name': 'escalacomosesente',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('escaladisposicaoantesdasecao', {
            'name': 'escaladisposicaoantesdasecao',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('estadocontroleinterno', {
            'name': 'estadocontroleinterno',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('logdoprocessoderegistro', {
            'name': 'logdoprocessoderegistro',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Profile)
model_rebuild(Role)
model_rebuild(Gym)
model_rebuild(UserType)
model_rebuild(Account)
model_rebuild(Session)
model_rebuild(VerificationToken)
model_rebuild(Todo)
model_rebuild(QuestionarioProntidaoAvaliacaoFisica)
model_rebuild(FormularioAvaliacaoFisica)
model_rebuild(Treino)
model_rebuild(RegistraTreino)
